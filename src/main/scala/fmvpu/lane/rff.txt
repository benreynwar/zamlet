Registers
---------
0 - packet word out (write only) (read gives 0)
1 - general (accumulator)
2 - general (mask)
3 - general (base address)
4 - general (channel)
5 - general
6 - general
7 - general

Note: We could use special addresse for accumulator, mask, base address and channel.
      But won't implement that unless necessary.
      i.e. Command like SetSpecial base_address = reg3
      Which would allow reg3 to be used for other things but base_address to keep it's value.


Register File and Friends
-------------------------

inputs
  start_valid
  start_pc

  i_valid
  i_instruction (contains up to 2 regs that we want to read from the mem)
                (and an additional 2 where the address is hardcoded but we need to check avail)

  (the writes from the alu, ldst and packets)
  write_valids[2:0]  (writes coming from the ALU or store or packets)
  write_values[2:0][31:0] (write values)
  write_addresses[2:0][3+2-1:0] (3 bit reg + 2 bit w ident)

  alu_ready  (there's room in the reservation station)
  ldst_ready
  packets_ready

outputs
  aluinstr_valid
  aluinstr_mode
  aluinstr_src1     (32 bits data or 3+2 addr + wident)  33bit total (read1)
  aluinstr_src2     (32 bits data or 3+2 addr + wident)  33bit total (read2) 
  aluinstr_accum    (32 bits data or 3+2 addr + wident)  33bit total (hardwired to an addr)
  aluinstr_dst_addr

  ldstinstr_valid
  ldstinstr_mode
  ldstinstr_base_address (8 bit address or 2 bit w ident) (9 bit total)
  ldstinstr_offset (8 bit address or 3 bit reg + 2 bit w ident) (9 bit total)
  ldstinstr_dst_addr (3 bit reg address + 2 bit w ident)
  ldstinstr_value (32 bit value or 3 bit reg address + 2 bit w ident) (33 bit total)
    i_value and i_dst_addr is either or so we can manage with 33 bit for both

  packetinstr_valid   1 bit
  packetinstr_mode    2 bits (receive, send, get_word)
  packetinstr_target  10 bits or 3+2 (11  bits total) (read 1)
  packetinstr_result  3 bits (what register to put the length or word in) (write)
  packetinstr_send_length  (8 bits or 3+2) (bits total) (read 2)
  packetinstr_channel 2 bits
 
  imread_valid
  imread_address

constants
  WRITE_INDENT_WIDTH = 2
  We have pow(2, WRITE_IDENT_WIDTH) different writes for the same reg that can be in flight at a time.
    (I think this is what people mean by register renaming. At least it is similar).

structures
  Each register stores the following data.
    Value (32 bits)
    InFlight (WRITE_IDENT_WIDTH**2 bits) (Which write idents are in flight)
    LastIdent (WRITE_IDENT_WIDTH) (The last write ident to be issued)
    Local (1 bit, indicates that the register has been written locally (e.g. loop_index or loop_length)

  Each reg_read_info has
    1 bit (whether we have data or reg address + write_ident)
    Union of:
      - data 32 bits
      OR
      - reg address 3 bits
      - write_ident WRITE_IDENT_WIDTH bits
    For a total of 33 bits


Update register info:
  We monitor write_valids, write_values, write_addresses.
  When a write comes in for an address with a write_ident that matches LastIdent and it is not Local then we update the value.
  When a write comes in we unmark InFlight corresponding to the reg address and write_ident.

  When an instruction is processed that is a write to a register we update LastIdent and mark
  InFlight.  We set Local to 0.

Reading:
  An instruction can read from two addresses in the register file.
  If there are no InFlight writes or it is Local then we take the value.
  If there are InFlight writes then we take the (reg address and LastIdent)
  The result of the read will be a reg_read_info.
  As well as the two standard reads we also read registers 1, 2, 3 since their use
    is hardcoded into some instructions.  They also return a reg_read_info

  

Loops and Program Counter:

  The default for the program counter is to get incremented by 1.
  If we're in a loop we have two additional variables:
    loop_active
    loop_start_pc
    loop_end_pc
    loop_last
  If pc=loop_active and pc==loop_end_pc and !loop_last then pc=loop_start_pc
  If pc=loop_activ and pc==loop_end_pc and loop_last then pc=pc+2 (jump over the End Loop instruction)
  Else pc = pc+1
  We also update loop_last by looking at loop_index and loop_length

  If the current pc is loop_end_pc and we have loop_active and !loop_last
    set pc = loop_start_pc
    set loop_last = (loop_index+1 == loop_length-1)
    set loop_index = loop_index+1 (also write to register and set Local to 1)

    Note: Due to pipelining we may have sent the wrong pc last cycle.
          We'll need to cancel this. It's probably only one cycle so we can just
          ignore the instruction coming out of the IM next cycle.

  If the loop_size == 0 then we need to get an loop_size instruction.
  That should be the next instruction.
  Once we have the loop_size we know:
    loop_start_pc = pc+1
    loop_end_pc = pc+1+loop_size
    loop_index = 0
    loop_active = 1
  If the loop_length_reg has not resovled then
    We block until this register resolves.
  Once we have the length:
    If the length is 0 then:
      pc = loop_end_pc + 1
      loop_active = 0
    Else
      loop_last = length_length==1
      pc = pc + 1

  The loop_index is written to a register specified in the loop_start instruction whenever we start a loop iteration.
  The Local field is set to 1 when it is written.


Blocking:
  If we are stalled due to not getting a ready signal from a reservation station or due to waiting for
  a loop length to resolve, then imread_valid = 0 (just to save a bit of power on the IM).
