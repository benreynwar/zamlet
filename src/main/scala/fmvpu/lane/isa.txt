ISA
===

Mask Bit (Conditional Execution)
-------------------------------

All instructions include a mask bit (bit 9) for predicated execution:
- mask bit = 0: Execute instruction unconditionally
- mask bit = 1: Check mask register (register 2) bit 0:
  - If mask register bit 0 = 1: Skip instruction execution (destination unchanged)  
  - If mask register bit 0 = 0: Execute instruction normally

This enables conditional execution and SIMD-style masking operations.

Packet Instructions
-------------------
 - Modes
   0: Receive
   1: Receive and Forward
   2: Receive, Forward and Append
   3: Forward and Append
   4: Send
   5: Get Packet Word
   6: Broadcast

 2 bits 00           (bits 15-14)
 3 bits for mode     (bits 13-11)
 1 bit forwardAgain  (bit 10)
 1 bit mask          (bit 9)
 3 bits location     (bits 8-6)  (read 1)
 3 bits send length  (bits 5-3)  (read 2)
 3 bits result       (bits 2-0)  (write)  //also stores append length (for send mode)

Load and Store Instructions
---------------------------
Load from address to reg
Store from reg to address (base address in reg, offset in reg)

  2 bits 01           (bits 15-14)
  2 bits for mode     (bits 13-12)
  1 bit unused        (bit 11)
  1 bit use_base      (bit 10)
  1 bit mask          (bit 9)
  3 bits offset reg   (bits 8-6)  (read 1)
  3 bits src reg      (bits 5-3)  (read 2) 
  3 bits dest reg     (bits 2-0)  (write)

ALU Instruction
---------------

Mode 0 = Add      : result = src1 + src2
Mode 1 = Addi     : result = src1 + immediate (src2 as immediate)
Mode 2 = Sub      : result = src1 - src2  
Mode 3 = Subi     : result = src1 - immediate (src2 as immediate)
Mode 4 = Mult     : result = src1 * src2
Mode 5 = MultAcc  : result = accumulator + (src1 * src2)
                    (accumulator = register 1, updated when writing to reg 1)
Mode 6-15 Not set yet.

Note: For MultAcc, the accumulator value comes from register 1.
      When the result is written back to register 1, it updates the
      internal accumulator state for subsequent MultAcc operations.

  2 bits 10           (bits 15-14)
  4 bits mode         (bits 13-10)
  1 bit mask          (bit 9)
  3 bits src1         (bits 8-6)  (read 1)
  3 bits src2         (bits 5-3)  (read 2)
  3 bits dest         (bits 2-0)  (write)

Loop Instructions
-----------------

Start Loop:
  2 bits 11           (bits 15-14)
  2 bits 00           (bits 13-12)
  2 bits mode 00      (bits 11-10)
  1 bit mask          (bit 9)
  3 bits length reg   (bits 8-6)  (read 1)
  3 bits unused       (bits 5-3)  (read 2)
  3 bits index reg    (bits 2-0)  (write)

Loop Size:
  2 bits 11           (bits 15-14)
  2 bits 00           (bits 13-12)
  2 bits mode 11      (bits 11-10)
  10 bits loop_size   (bits 9-0)
    (The last instruction within the loop has an address that is equal to the first_instruction + loop_size)
    (There must always be at least one instruction in a loop)

Misc Instructions
-----------------

Halt:
  2 bits 11           (bits 15-14)
  2 bits 01           (bits 13-12)
  2 bits mode 00      (bits 11-10)
  10 bits unused
   

If we want to make it general the 16 bits

6 bits mode + channel/use_base_address etc
1 bit mask
3 bits (read 1)
3 bits (read 2)
3 bits (write)
