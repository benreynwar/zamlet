# FMVPU Code Style Guidelines

This document contains style guidelines for consistent code formatting across the FMVPU project.

## Chisel Style Guidelines

### Module Structure
- Always use `val io = IO(new Bundle { ... })` pattern for module interfaces
- Bundle fields should be properly indented (2 spaces)
- Use Input/Output directions explicitly in Bundle definitions

```scala
class MyModule(params: MyParams) extends Module {
  val io = IO(new Bundle {
    val input1 = Input(UInt(32.W))
    val output1 = Output(UInt(32.W))
  })
  // module implementation
}
```

### Bundle Definitions
- Remove extra spaces around `=` in field definitions
- Use consistent spacing: `val field = Type` (single space around =)
- Group related fields together with blank lines

```scala
class MyBundle(params: MyParams) extends Bundle {
  val mode = UInt(4.W)
  val src1 = UInt(log2Ceil(params.nRegs).W)
  val src2 = UInt(log2Ceil(params.nRegs).W)
  
  val addr = UInt(params.addrWidth.W)
  val data = UInt(params.dataWidth.W)
}
```

### Naming Conventions
- Use camelCase for signal names: `drf`, `ddm`, `networkNode`
- Use PascalCase for types and modules: `Lane`, `NetworkNode`
- Use descriptive names for wires and registers

### Spacing and Operators
- Use spaces around operators: `params.nRows + 1` not `params.nRows+1`
- Use spaces around assignment operators: `signal := value`
- Use spaces in array indices: `lanes(row)(col - 1)` not `lanes(row)(col-1)`

### Generator Objects
- Remove unnecessary semicolons and explicit return statements
- Use consistent indentation (2 spaces)

```scala
object MyModuleGenerator extends ModuleGenerator {
  override def makeModule(args: Seq[String]): Module = {
    if (args.length < 1) {
      println("Usage: <command> <outputDir> MyModule <paramsFileName>")
      return null
    }
    val params = MyParams.fromFile(args(0))
    new MyModule(params)
  }
}
```

## Cocotb Style Guidelines

### Type Hints
- Use comprehensive type hints for all function parameters and return types
- Import necessary types from `typing` module
- Use `HierarchyObject` for DUT parameters

```python
from typing import Any, Deque
from cocotb.handle import HierarchyObject

async def my_function(dut: HierarchyObject, data: Deque[int]) -> None:
    """Function description."""
    # implementation
```

### Imports
- Group imports: standard library, third-party, local imports
- Use specific imports when possible: `from cocotb.clock import Clock`
- Avoid wildcard imports

```python
import os
import json
from typing import Any, Deque

import cocotb
from cocotb import triggers
from cocotb.clock import Clock
from cocotb.handle import HierarchyObject

from fmpvu import generate_rtl, test_utils
```

### Function Documentation
- Use triple-quoted docstrings for all functions
- Include brief description and parameter/return information
- Use descriptive function names

```python
async def reset_dut(dut: HierarchyObject) -> None:
    """Apply standard reset sequence to the DUT."""
    dut.reset.value = 0
    await triggers.RisingEdge(dut.clock)
    dut.reset.value = 1
    await triggers.RisingEdge(dut.clock)
    dut.reset.value = 0
    await triggers.RisingEdge(dut.clock)
```

### Clock Generation
- Use `Clock` class for clock generation
- Specify units explicitly: `Clock(dut.clock, 1, units='ns')`
- Start clock with `cocotb.start_soon(clock.start())`

### Test Structure
- Use `@cocotb.test()` decorator for test functions
- Include comprehensive docstrings
- Initialize all signals to safe values before starting
- Use timeout watchdogs for safety

### Error Messages
- Include descriptive assertion messages
- Use f-strings for formatted messages: `f"Expected {expected}, got {actual}"`
- Provide context in error messages

### Naming Conventions
- Use snake_case for functions and variables
- Use descriptive names: `timeout_watchdog` not `timeout`
- Use clear prefixes: `test_` for test functions

### Background Tasks
- Use descriptive names for background tasks
- Properly kill background tasks when done
- Use `cocotb.start_soon()` for concurrent operations

## General Guidelines

### Comments
- Use meaningful comments to explain complex logic
- Avoid obvious comments
- Use TODO comments for future improvements

### File Organization
- Group related functions together
- Put helper functions before main test functions
- Use blank lines to separate logical sections

### Error Handling
- Provide helpful error messages
- Use assertions with descriptive messages
- Handle edge cases appropriately