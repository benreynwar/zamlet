import logging
from typing import List, Tuple
from dataclasses import dataclass

import addresses
from addresses import KMAddr
from params import LamletParams
from jamlet import Jamlet
from message import Header, MessageType, SendType, AddressHeader
from utils import Queue
import kinstructions
import memlet
from kinstructions import KInstr
import utils
import register_file_slot
from cache_table import CacheRequestType, CacheState, CacheTable


logger = logging.getLogger(__name__)


SEND_READ_LINE_J_INDEX = 1


class Kamlet:
    """
    A collection of lanes.
    They share an instruction buffer, and cache tracking logic.
    """

    def __init__(self, clock, params: LamletParams, min_x: int, min_y: int):
        self.clock = clock
        self.params = params

        # A kamlet covers several (x,y) coordinate positions (one for each lane (jamlet))
        self.min_x = min_x
        self.min_y = min_y
        self.n_columns = params.j_cols
        self.n_rows = params.j_rows
        self.n_jamlets = self.n_columns * self.n_rows

        k_x = self.min_x//params.j_cols
        k_y = self.min_y//params.j_rows
        k_index = k_y * params.k_cols + k_x
        mem_coords = memlet.m_router_coords(params, k_index, 0)
        self.mem_x = mem_coords[0]
        self.mem_y = mem_coords[1]

        self.available_instruction_tokens = self.params.instruction_queue_length

        # We pass methods to the cache table to flush and read lines.
        name = f'CacheTable ({self.min_x}, {self.min_y})'
        self.cache_table = CacheTable(clock, params, name)

        self.jamlets = []
        for index in range(self.n_jamlets):
            x = min_x+index % self.n_columns
            y = min_y+index//self.n_columns
            self.jamlets.append(Jamlet(clock, params, x, y, self.cache_table))

        # Local State
        self._instruction_queue = Queue(self.params.instruction_queue_length)

        # We place packets here that are generated by instructions.
        self._instr_send_queue = Queue(2)

        self.rf_info = [register_file_slot.KamletRegisterFileSlot(f'v{index}') for _ in range(self.params.n_vregs)]

    def rf_available(self, read_regs=None, write_regs=None):
        if read_regs is None:
            read_regs = []
        if write_regs is None:
            write_regs = []
        avail = (all(self.rf_info[r].can_read() for r in read_regs) and
                 all(self.rf_info[r].can_write() for r in write_regs))
        for reg in read_regs:
            if not self.rf_info[reg].can_read():
                logger.debug(f'Cannot read {self.rf_info[reg].name}')
        for reg in write_regs:
            if not self.rf_info[reg].can_write():
                logger.debug(f'Cannot write {self.rf_info[reg].name}')
        return avail

    async def wait_for_rf_available(self, read_regs=None, write_regs=None):
        while not self.rf_available(read_regs, write_regs):
            await self.clock.next_cycle

    def update(self):
        self._instruction_queue.update()
        self._instr_send_queue.update()
        self.cache_table.update()
        for jamlet in self.jamlets:
            jamlet.update()

    @property
    def k_index(self):
        return self.min_y // self.params.j_rows * self.params.k_cols + self.min_x // self.params.j_cols

    def get_jamlet(self, x, y):
        assert self.min_x <= x < self.min_x + self.n_columns
        assert self.min_y <= y < self.min_y + self.n_rows
        jamlet = self.jamlets[(y - self.min_y) * self.n_columns + (x - self.min_x)]
        assert jamlet.x == x
        assert jamlet.y == y
        return jamlet

    def add_to_instruction_queue(self, instr: kinstructions.KInstr):
        assert isinstance(instr, kinstructions.KInstr)
        self._instruction_queue.append(instr)

    async def _run_instructions(self):
        while True:
            await self.clock.next_cycle
            # If we have an instruction then do it
            if self._instruction_queue:
                self.available_instruction_tokens += 1
                instruction = self._instruction_queue.popleft()
                logger.warning(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: running {instruction}')
                await instruction.update_kamlet(self)
                logger.warning(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: finished instruction')

    def take_instruction_token(self):
        assert self.available_instruction_tokens > 0
        self.available_instruction_tokens -= 1

    async def _monitor_cache_requests(self):
        while True:
            await self.clock.next_cycle
            for request in self.cache_table.cache_requests:
                if request is None:
                    continue
                if not all(request.sent):
                    if request.request_type == CacheRequestType.READ_LINE:
                        await self.read_cache_line(cache_slot=request.slot, address_in_memory=request.addr, ident=request.ident)
                        self.cache_table.report_sent_request(request)
                    else:
                        # Don't do anything for WRITE_LINE or WRITE_LINE_READ_LINE
                        # since those messages are sent at the jamlet level.
                        pass

    async def _get_instructions_from_jamlets(self):
        while True:
            await self.clock.next_cycle
            # Get received instructions from jamlets
            for index, jamlet in enumerate(self.jamlets):
                if jamlet._instruction_buffer:
                    if index == 0:
                        logger.warning('Got an instruction from jamlet')
                        if self._instruction_queue.can_append():
                            instr = jamlet._instruction_buffer.popleft()
                            logger.warning(f'Adding {type(instr)} to queue')
                            self.add_to_instruction_queue(instr)
                    else:
                        instr = jamlet._instruction_buffer.popleft()

    async def run(self):
        for jamlet in self.jamlets:
            self.clock.create_task(jamlet.run())
        self.clock.create_task(self._run_instructions())
        self.clock.create_task(self._send_packets())
        self.clock.create_task(self._get_instructions_from_jamlets())
        self.clock.create_task(self._monitor_cache_requests())
        self.clock.create_task(self._monitor_items())
        self.clock.create_task(self.cache_table.run())

    async def read_cache_line(self, cache_slot: int, address_in_memory: int, ident: int):
        """
        Reads from memory into the cache line.
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        logger.warning('Reading cache line')
        address_in_sram = cache_slot * self.params.cache_line_bytes // self.params.j_in_k

        header = AddressHeader(
            message_type=MessageType.READ_LINE, #4
            send_type=SendType.SINGLE,          #1
            target_x=self.mem_x,                #8
            target_y=self.mem_y,                #8
            source_x=self.min_x,                #8
            source_y=self.min_y,                #8
            address=address_in_sram,            #12
            length=2,                           #5
            ident=ident,               #5 bits
            )
        packet = [header, address_in_memory]

        while not self._instr_send_queue.can_append():
            await self.clock.next_cycle
        self._instr_send_queue.append(packet)

    #async def write_cache_line(self, cache_slot: int, address_in_memory: int):
    #    """
    #    Write from cache line into the memory
    #    This function should only be called by our CacheTable.
    #    We pass it to the cache table's constructor.
    #    """
    #    label = ('WRITE_LINE', (self.min_x, self.min_y), address_in_memory)
    #    response_ident, futures = await self.response_tracker.register_count([None], label)
    #    future = futures[0]
    #    tasks = []
    #    for jamlet in self.jamlets:
    #        # Create tasks so these jamlets can run in parallel.
    #        tasks.append(self.clock.create_task(jamlet.write_cache_line(cache_slot, address_in_memory, response_ident)))
    #    # Block until the jamlets all send the packets.
    #    for task in tasks:
    #        await task
    #    return future

    async def handle_write_imm_bytes_instr(self, instr: kinstructions.WriteImmBytes, step=0):
        """
        Writes bytes to memory.
        They must all be within one word.
        """
        if step == 0:
            logger.warning(f'{self.clock.cycle}: {(self.min_x, self.min_y)}: handle_write_imm_bytes_instr: {hex(instr.k_maddr.addr)}')
            if not self.cache_table.can_write(instr.k_maddr):
                logger.warning('Requesting cache')
                item_index = await self.cache_table.request_write(instr.k_maddr, instr, step=1)
                logger.warning(f'item index is {item_index}')
            else:
                await self.handle_write_imm_bytes_instr(instr, step=1)
        elif step == 1:
            logger.warning('Got cache. Updated jamlet sram')
            assert instr.k_maddr.bit_addr % 8 == 0
            if instr.k_maddr.k_index == self.k_index:
                assert self.cache_table.can_write(instr.k_maddr)
                j_saddr = instr.k_maddr.to_j_saddr(self.cache_table)
                jamlet = self.jamlets[j_saddr.j_in_k_index]
                size = len(instr.imm)
                jamlet.sram[j_saddr.addr: j_saddr.addr+size] = instr.imm
        else:
            raise NotImplementedError()

    async def handle_read_byte_instr(self, instr: kinstructions.ReadByte, step: int):
        if step == 0:
            logger.warning('kamlet: handle_ready_bytes_instr')
            if not self.cache_table.can_read(instr.k_maddr):
                await self.cache_table.request_read(instr.k_maddr, item=instr, step=1)
            else:
                await self.handle_read_byte_instr(instr=instr, step=1)
        elif step == 1:
            logger.warning('We handling the read. The cache should be updated')
            assert instr.k_maddr.bit_addr % 8 == 0
            if instr.k_maddr.k_index == self.k_index:
                assert self.cache_table.can_read(instr.k_maddr)
                j_saddr = instr.k_maddr.to_j_saddr(self.cache_table)
                jamlet = self.jamlets[j_saddr.j_in_k_index]
                await jamlet.handle_read_byte_instr(instr, j_saddr.addr)
        else:
            raise NotImplementedError()

    async def handle_load_byte_instr(self, instr: kinstructions.LoadByte):
        # We need to load a byte from memory.
        # There are two aspects to this.
        # 1) We are the kamlet that it will be loaded from. We need to update our
        #    cache state to indicate that we are in the process of reading. If
        #    we have it in the cache we can send a LOAD_BYTE_RESP message to the
        #    target.
        # 2) We are the kamlet that is loading.  We mark our register as
        #    updating.
        is_src = instr.src.k_index == self.k_index
        is_dst = instr.dst.k_index == self.k_index
        done = False
        if is_src and is_dst and instr.src.j_in_k_index == instr.dst.j_in_k_index:
            # It's the same jamlet.
            slot = self.cache_table.get_state(instr.src)
            if slot is not None:
                jamlet = self.jamlets[instr.dst.j_in_k_index]
                src_offset_in_word = instr.src.addr % self.params.word_bytes
                rf_addr = instr.dst.reg * self.params.word_bytes + instr.dst.offset_in_word
                sram_addr = slot * self.params.word_bytes + src_offset_in_word
                jamlet.rf_slice[rf_addr] = jamlet.sram[sram_addr]
                done = True
        if not done:
            if is_src:
                slot = self.cache_table.get_state(instr.src)
                if slot is None:
                    future = await self.cache_table.request_read(instr.k_maddr, coro)


        if is_src:
            src_jamlet = self.jamlets[instr.src.j_in_k_index]
            await src_jamlet.handle_load_byte(instr)
            if is_dst and instr.src_j_in_k_index != instr.dst.j_in_k_index:
                dst_jamlet = self.jamlets[instr.dst.j_in_k_index]
                await dst_jamlet.handle_load_byte(instr)
        elif is_dst:
            dst_jamlet = self.jamlets[instr.dst.j_in_k_index]
            await dst_jamlet.handle_load_byte(instr)

    async def handle_load_word_instr(self, instr: kinstructions.LoadWord):
        raise NotImplementedError()

    async def handle_load_instr(self, instr: kinstructions.Load):
        logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)}')
        assert instr.element_width == instr.k_maddr.ordering.ew
        vline_bits = self.params.vline_bytes * 8
        n_vlines = (instr.n_elements * instr.element_width + vline_bits)//vline_bits
        elements_in_vline = vline_bits//instr.element_width

        write_regs = [instr.dst+index for index in range(n_vlines)]
        if instr.mask_reg is not None:
            read_regs = [instr.mask_reg]
        else:
            read_regs = []
        await self.wait_for_rf_available(write_regs=write_regs, read_regs=read_regs)

        # Check that the address is aligned to a vector line.
        assert instr.k_maddr.k_index == 0
        assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

        # Make sure that we have all the cache lines that we need for reading.
        futures = []
        for vline_index in range(n_vlines):
            m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
            k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
            # We register our desire to read each vline independently since they
            # may be on different cache lines.
            write_token = self.rf_info[instr.dst + vline_index].start_write()
            if instr.mask_reg is not None:
                read_token = self.rf_info[instr.mask_reg].start_read()
            else:
                read_token = None
            coro = self._handle_load_instr_resolve(instr, vline_index, write_token, read_token)
            futures.append(await self.cache_table.request_read(k_maddr, coro))

        combined_future = self.clock.create_future()
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)} done')
        return combined_future

    def get_is_active(self, n_elements, element_width, word_order, mask_reg, vline_index, j_in_k_index, index_in_j):
        wb = self.params.word_bytes
        eb = element_width // 8
        elements_in_vline = self.params.vline_bytes*8//element_width
        jamlet = self.jamlets[j_in_k_index]
        vw_index = addresses.k_indices_to_vw_index(
                self.params, word_order, self.k_index, j_in_k_index)
        element_index = vline_index*elements_in_vline + index_in_j * self.params.j_in_l + vw_index
        valid_element = element_index < n_elements
        if mask_reg is not None:
            mask_bit_addr = mask_reg * wb * 8 + vline_index * (wb//eb) + index_in_j
            mask_byte = jamlet.rf_slice[mask_bit_addr//8]
            mask_bit = (mask_byte >> (mask_bit_addr % 8)) & 1
        else:
            mask_bit = 1
        return valid_element, mask_bit

    async def _handle_load_instr_resolve(self, instr, vline_index, write_token, read_token):
        # This handles just one vline worth of data.
        # This guarantees that it will all be in the same cache line
        logger.info(f'kamlet ({self.min_x} {self.min_y}): _handle_load_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index} mask_reg={instr.mask_reg}')
        wb = self.params.word_bytes
        eb = instr.element_width//8
        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
        j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
        assert instr.element_width % 8 == 0
        assert self.cache_table.can_read(k_maddr)
        mask_values = []
        valids = []
        old_values = []
        new_values = []
        loaded_values = []
        for j_in_k_index, jamlet in enumerate(self.jamlets):
            for index_in_j in range(wb//eb):
                valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
                                            instr.mask_reg,  vline_index, j_in_k_index, index_in_j)
                active = valid_element and mask_bit
                base_rf_addr = instr.dst*wb + vline_index*wb + index_in_j*eb
                base_sram_addr = j_saddr.addr + index_in_j*eb
                old_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
                if active:
                    jamlet.rf_slice[base_rf_addr: base_rf_addr + eb] = jamlet.sram[base_sram_addr: base_sram_addr + eb]
                loaded_values.append(int.from_bytes(jamlet.sram[base_sram_addr: base_sram_addr + eb], byteorder='little'))
                new_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
                mask_values.append(mask_bit)
                valids.append(valid_element)
        self.rf_info[instr.dst + vline_index].finish_write(write_token)
        if read_token is not None:
            self.rf_info[instr.mask_reg].finish_read(read_token)
        logger.info(f'kamlet: _handle_load_instr_resolve, base rf address={instr.dst*wb + vline_index*wb} masks are is {mask_values} valids are {valids} old_values {old_values} loaded_values = {loaded_values} new_values {new_values}')

    async def handle_store_instr(self, instr: kinstructions.Store):
        logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')

        assert instr.element_width == instr.k_maddr.ordering.ew
        vline_bits = self.params.vline_bytes * 8
        n_vlines = (instr.n_elements * instr.element_width + vline_bits)//vline_bits

        read_regs = [instr.src+index for index in range(n_vlines)]
        if instr.mask_reg is not None:
            read_regs.append(instr.mask_reg)
        await self.wait_for_rf_available(read_regs=read_regs)

        # Check that the address is aligned to a vector line.
        assert instr.k_maddr.k_index == 0
        assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

        # Make sure that we have all the cache lines that we need for writing.
        futures = []
        for vline_index in range(n_vlines):
            m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
            k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
            # We register our desire to write each vline independently since they
            # may be on different cache lines.
            read_tokens = [self.rf_info[instr.src+vline_index].start_read()]
            if instr.mask_reg is not None:
                read_tokens.append(self.rf_info[instr.mask_reg].start_read())
            coro = self._handle_store_instr_resolve(instr, vline_index, read_tokens)
            futures.append(await self.cache_table.request_write(k_maddr, coro))

        combined_future = self.clock.create_future()
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        return combined_future

    async def _handle_store_instr_resolve(self, instr, vline_index, read_tokens):
        # This handles just one vline worth of data.
        # This guarantees that it will all be in the same cache line
        logger.info(f'kamlet: _handle_store_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index}, mask_reg is {instr.mask_reg}')
        wb = self.params.word_bytes
        eb = instr.element_width//8
        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
        j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
        assert instr.element_width % 8 == 0
        assert self.cache_table.can_write(k_maddr)
        mask_values = []
        for index_in_j in range(wb//eb):
            for j_in_k_index, jamlet in enumerate(self.jamlets):
                valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
                                            instr.mask_reg, vline_index, j_in_k_index, index_in_j)
                if valid_element and mask_bit:
                    base_rf_addr = instr.src*wb + vline_index*wb + index_in_j*eb
                    base_sram_addr = j_saddr.addr + index_in_j*eb
                    jamlet.sram[base_sram_addr: base_sram_addr + eb] = jamlet.rf_slice[base_rf_addr: base_rf_addr + eb]
                mask_values.append(mask_bit)
        self.rf_info[instr.src + vline_index].finish_read(read_tokens[0])
        if len(read_tokens) > 1:
            self.rf_info[instr.mask_reg].finish_read(read_tokens[1])
        logger.info(f'kamlet: _handle_store_instr_resolve, masks are is {mask_values}')

    async def handle_read_reg_element_instr(self, instr: kinstructions.ReadRegElement):
        """Handle reading an element from vector register."""
        logger.debug(f'kamlet: handle_read_reg_element_instr src=v{instr.src} element={instr.element_index}')
        await self.wait_for_rf_available(read_regs=[instr.src])

        params = self.params
        vreg_bytes_per_jamlet = params.maxvl_bytes // params.j_in_l
        eb = instr.element_width // 8

        # Calculate which jamlet and offset within that jamlet
        vw_index = instr.element_index % params.j_in_l
        k_index, j_in_k_index = addresses.vw_index_to_k_indices(params, addresses.WordOrder.STANDARD, vw_index)
        element_in_jamlet = instr.element_index // params.j_in_l

        if k_index == self.k_index:
            jamlet = self.jamlets[j_in_k_index]
            src_offset = instr.src * vreg_bytes_per_jamlet + element_in_jamlet * eb
            value_bytes = bytes(jamlet.rf_slice[src_offset:src_offset + eb])

            # Send response message back to lamlet
            header = Header(
                message_type=MessageType.READ_BYTES_RESP,
                send_type=SendType.SINGLE,
                value=value_bytes,
                target_x=jamlet.front_x,
                target_y=jamlet.front_y,
                source_x=jamlet.x,
                source_y=jamlet.y,
                address=None,
                length=1,
                ident=instr.ident,
            )
            packet = [header]
            send_queue = jamlet.send_queues[header.message_type]
            while not send_queue.can_append():
                await self.clock.next_cycle
            send_queue.append(packet)

    async def handle_item(self, item):
        if isinstance(item.item, kinstructions.WriteImmBytes):
            await self.handle_write_imm_bytes_instr(item.item, step=1)
        elif isinstance(item.item, kinstructions.ReadByte):
            await self.handle_read_byte_instr(item.item, step=1)
        else:
            raise NotImplementedError()

    async def _monitor_items(self):
        while True:
            await self.clock.next_cycle
            for index, item in enumerate(self.cache_table.waiting_items):
                if item is None:
                    continue
                if any(x.dropped_notification for x in item.response_infos):
                    assert False
                if (all(x.received for x in item.response_infos) and item.cache_slot is None
                        or item.cache_is_avail):
                    await self.handle_item(item)
                    self.cache_table.waiting_items[index] = None

    async def _send_packets(self):
        while True:
            await self.clock.next_cycle
            if self._instr_send_queue:
                packet = self._instr_send_queue.popleft()
                buffer = self.jamlets[SEND_READ_LINE_J_INDEX].send_queues[packet[0].message_type]
                while not buffer.can_append():
                    await self.clock.next_cycle
                buffer.append(packet)
