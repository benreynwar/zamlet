import logging

from cache_table import CacheTable
from addresses import KMAddr
from params import LamletParams
from jamlet import Jamlet
from message import Header, MessageType, SendType
from utils import Queue
import kinstructions
import memlet
from response_tracker import ResponseTracker
import utils


logger = logging.getLogger(__name__)


SEND_READ_LINE_J_INDEX = 1


class Kamlet:
    """
    A collection of lanes.
    They share an instruction buffer, and cache tracking logic.
    """

    def __init__(self, clock, params: LamletParams, min_x: int, min_y: int):
        self.clock = clock
        self.params = params

        # A kamlet covers several (x,y) coordinate positions (one for each lane (jamlet))
        self.min_x = min_x
        self.min_y = min_y
        self.n_columns = params.j_cols
        self.n_rows = params.j_rows
        self.n_jamlets = self.n_columns * self.n_rows

        k_x = self.min_x//params.j_cols
        k_y = self.min_y//params.j_rows
        k_index = k_y * params.k_cols + k_x
        mem_coords = memlet.m_router_coords(params, k_index, 0)
        self.mem_x = mem_coords[0]
        self.mem_y = mem_coords[1]

        self.available_instruction_tokens = self.params.instruction_queue_length

        # We pass methods to the cache table to flush and read lines.
        name = f'CacheTable ({self.min_x}, {self.min_y})'
        self.cache_table = CacheTable(clock, params, self.write_cache_line, self.read_cache_line, name)

        # Keeps track of the messages that we've sent where we
        # are expecting a response.
        self.response_tracker = ResponseTracker(clock, params)

        self.jamlets = []
        for index in range(self.n_jamlets):
            x = min_x+index % self.n_columns
            y = min_y+index//self.n_columns
            self.jamlets.append(Jamlet(clock, params, x, y, self.response_tracker))

        # Local State
        self._instruction_queue = Queue(self.params.instruction_queue_length)

        # We place packets here that are generated by instructions.
        self._instr_send_queue = Queue(2)

        self.rf_updating = [False] * self.params.n_vregs

    def rf_available(self, regs):
        avail = not any(self.rf_updating[reg] for reg in regs)
        return avail

    async def wait_for_rf_available(self, regs):
        while not self.rf_available(regs):
            await self.clock.next_cycle

    def update(self):
        self._instruction_queue.update()
        self._instr_send_queue.update()
        for jamlet in self.jamlets:
            jamlet.update()

    @property
    def k_index(self):
        return self.min_y // self.params.j_rows * self.params.k_cols + self.min_x // self.params.j_cols

    def get_jamlet(self, x, y):
        assert self.min_x <= x < self.min_x + self.n_columns
        assert self.min_y <= y < self.min_y + self.n_rows
        jamlet = self.jamlets[(y - self.min_y) * self.n_columns + (x - self.min_x)]
        assert jamlet.x == x
        assert jamlet.y == y
        return jamlet

    def add_to_instruction_queue(self, instr: kinstructions.KInstr):
        assert isinstance(instr, kinstructions.KInstr)
        self._instruction_queue.append(instr)

    async def _run_instructions(self):
        while True:
            await self.clock.next_cycle
            # If we have an instruction then do it
            if self._instruction_queue:
                self.available_instruction_tokens += 1
                instruction = self._instruction_queue.popleft()
                logger.info(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: running {instruction}')
                await instruction.update_kamlet(self)

    def take_instruction_token(self):
        assert self.available_instruction_tokens > 0
        self.available_instruction_tokens -= 1

    async def run(self):
        for jamlet in self.jamlets:
            self.clock.create_task(jamlet.run())
        self.clock.create_task(self._run_instructions())
        self.clock.create_task(self._send_packets())
        while True:
            await self.clock.next_cycle
            # Get received instructions from jamlets
            for index, jamlet in enumerate(self.jamlets):
                if jamlet._instruction_buffer:
                    if index == 0:
                        if self._instruction_queue.can_append():
                            instr = jamlet._instruction_buffer.popleft()
                            self.add_to_instruction_queue(instr)
                    else:
                        instr = jamlet._instruction_buffer.popleft()

    async def read_cache_line(self, cache_slot: int, address_in_memory: int):
        """
        Reads from memory into the cache line.
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        address_in_sram = cache_slot * self.params.cache_line_bytes // self.params.j_in_k
        # Here we're registering what callback we'll use for each received response based on the
        # target of the received packet.
        dest_to_method = {(jamlet.x, jamlet.y): jamlet.read_cache_line_resolve for jamlet in self.jamlets}
        label = ('READ_LINE', address_in_memory)
        response_ident, dest_to_futures = await self.response_tracker.register_dsts(dest_to_method, label)

        header = Header(
            message_type=MessageType.READ_LINE, #4
            send_type=SendType.SINGLE,          #1
            target_x=self.mem_x,                #8
            target_y=self.mem_y,                #8
            source_x=self.min_x,                #8
            source_y=self.min_y,                #8
            address=address_in_sram,            #12
            length=2,                           #5
            ident=response_ident,               #5 bits
            )
        packet = [header, address_in_memory]

        while not self._instr_send_queue.can_append():
            await self.clock.next_cycle
        self._instr_send_queue.append(packet)

        # Create a future that will resolve when all of the jamlet callbacks have completed.
        combined_future = self.clock.create_future()
        futures = list(dest_to_futures.values())
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        return combined_future

    async def write_cache_line(self, cache_slot: int, address_in_memory: int):
        """
        Write from cache line into the memory
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        label = ('WRITE_LINE', (self.min_x, self.min_y), address_in_memory)
        response_ident, futures = await self.response_tracker.register_count([None], label)
        future = futures[0]
        tasks = []
        for jamlet in self.jamlets:
            # Create tasks so these jamlets can run in parallel.
            tasks.append(self.clock.create_task(jamlet.write_cache_line(cache_slot, address_in_memory, response_ident)))
        # Block until the jamlets all send the packets.
        for task in tasks:
            await task
        return future

    async def handle_write_imm_bytes_instr(self, instr: kinstructions.WriteImmBytes):
        """
        Writes bytes to memory.
        They must all be within one word.
        """
        logger.debug(f'{self.clock.cycle}: {(self.min_x, self.min_y)}: handle_write_imm_bytes_instr: {hex(instr.k_maddr.addr)}')
        # This is the corouine that will do the writing.
        coro = self._handle_write_imm_bytes_instr_resolve(instr)
        # But we don't actually run it until we have the cache ready.
        future = await self.cache_table.request_write(instr.k_maddr, coro)
        return future

    async def _handle_write_imm_bytes_instr_resolve(self, instr: kinstructions.WriteImmBytes):
        # Now we can write to the cache.
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_write(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.params, self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            size = len(instr.imm)
            jamlet.sram[j_saddr.addr: j_saddr.addr+size] = instr.imm

    async def handle_read_bytes_instr(self, instr: kinstructions.ReadBytes):
        logger.debug('kamlet: handle_ready_bytes_instr')
        # This is the corouine that will do the writing.
        coro = self._handle_read_bytes_instr_resolve(instr)
        # But we don't actually run it until we have the cache ready.
        future = await self.cache_table.request_read(instr.k_maddr, coro)
        return future

    async def _handle_read_bytes_instr_resolve(self, instr: kinstructions.WriteImmBytes):
        logger.debug('We handling the read. The cache should be updated')
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_read(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.params, self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            future = await jamlet.handle_read_bytes_instr(instr, j_saddr.addr)

    async def handle_load_instr(self, instr: kinstructions.Load):
        logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)}')
        regs = [instr.dst+index for index in range(instr.n_vlines)]
        for reg in regs:
            self.rf_updating[reg] = True
        assert instr.k_maddr.k_index == 0
        k_vline_bytes = self.params.word_bytes * self.params.j_in_k
        assert instr.k_maddr.addr % k_vline_bytes == 0
        # Make sure that we have all the cache lines that we need for reading.
        futures = []
        for vline_index in range(instr.n_vlines):
            m_addr = instr.k_maddr.addr + vline_index * k_vline_bytes
            k_maddr = KMAddr(k_index=self.k_index, ordering=None, bit_addr=m_addr*8)
            # We register our desire to read each vline independently since they
            # may be on different cache lines.
            coro = self._handle_load_instr_resolve(instr.dst + vline_index, k_maddr)
            futures.append(await self.cache_table.request_read(k_maddr, coro))
        combined_future = self.clock.create_future()
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        return combined_future

    async def _handle_load_instr_resolve(self, dst, k_maddr):
        # This handles just one vline worth of data.
        # This guarantees that it will all be in the same cache line
        logger.debug(f'kamlet: _handle_load_instr_resolve {hex(k_maddr.addr)}')
        wb = self.params.word_bytes
        assert self.cache_table.can_read(k_maddr)
        j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
        for jamlet in self.jamlets:
            jamlet.rf_slice[dst*wb: (dst+1)*wb] = jamlet.sram[j_saddr.addr: j_saddr.addr+wb]
        self.rf_updating[dst] = False

    async def handle_store_instr(self, instr: kinstructions.Store):
        assert instr.k_maddr.k_index == 0
        k_vline_bytes = self.params.word_bytes * self.params.j_in_k
        assert instr.k_maddr.addr % k_vline_bytes == 0
        # Make sure that we have all the cache lines that we need for reading.
        futures = []
        for vline_index in range(instr.n_vlines):
            m_addr = instr.k_maddr.addr + vline_index * k_vline_bytes
            k_maddr = KMAddr(k_index=self.k_index, ordering=None, bit_addr=m_addr*8)
            # We register our desire to read each vline independently since they
            # may be on different cache lines.
            coro = self._handle_store_instr_resolve(instr.src + vline_index, k_maddr)
            futures.append(await self.cache_table.request_write(k_maddr, coro))
        combined_future = self.clock.create_future()
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        return combined_future

    async def _handle_store_instr_resolve(self, dst, k_maddr):
        # This handles just one vline worth of data.
        # This guarantees that it will all be in the same cache line
        wb = self.params.word_bytes
        assert self.cache_table.can_write(k_maddr)
        j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
        for jamlet in self.jamlets:
            jamlet.sram[j_saddr.addr: j_saddr.addr+wb] = jamlet.rf_slice[dst*wb: (dst+1)*wb]

    async def _send_packets(self):
        while True:
            await self.clock.next_cycle
            if self._instr_send_queue:
                packet = self._instr_send_queue.popleft()
                buffer = self.jamlets[SEND_READ_LINE_J_INDEX].send_queues[packet[0].message_type]
                while not buffer.can_append():
                    await self.clock.next_cycle
                buffer.append(packet)
