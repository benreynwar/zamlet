import logging
from typing import List

import addresses
from addresses import KMAddr
from params import LamletParams
from jamlet import Jamlet
from message import Header, MessageType, SendType, AddressHeader
from utils import Queue
import kinstructions
import memlet
import register_file_slot
from cache_table import CacheRequestType, CacheTable, WaitingItem, WItemType


logger = logging.getLogger(__name__)


SEND_READ_LINE_J_INDEX = 1


class Kamlet:
    """
    A collection of lanes.
    They share an instruction buffer, and cache tracking logic.
    """

    def __init__(self, clock, params: LamletParams, min_x: int, min_y: int):
        self.clock = clock
        self.params = params

        # A kamlet covers several (x,y) coordinate positions (one for each lane (jamlet))
        self.min_x = min_x
        self.min_y = min_y
        self.n_columns = params.j_cols
        self.n_rows = params.j_rows
        self.n_jamlets = self.n_columns * self.n_rows

        k_x = self.min_x//params.j_cols
        k_y = self.min_y//params.j_rows
        k_index = k_y * params.k_cols + k_x
        mem_coords = memlet.m_router_coords(params, k_index, 0)
        self.mem_x = mem_coords[0]
        self.mem_y = mem_coords[1]

        self.available_instruction_tokens = self.params.instruction_queue_length

        # We pass methods to the cache table to flush and read lines.
        name = f'CacheTable ({self.min_x}, {self.min_y})'
        self.cache_table = CacheTable(clock, params, name)

        self.jamlets = []
        for index in range(self.n_jamlets):
            x = min_x+index % self.n_columns
            y = min_y+index//self.n_columns
            self.jamlets.append(Jamlet(clock, params, x, y, self.cache_table))

        # Local State
        self._instruction_queue = Queue(self.params.instruction_queue_length)

        # We place packets here that are generated by instructions.
        self._instr_send_queue = Queue(2)

        self.rf_info = [register_file_slot.KamletRegisterFileSlot(f'v{index}') for _ in range(self.params.n_vregs)]

    def rf_available(self, read_regs=None, write_regs=None):
        if read_regs is None:
            read_regs = []
        if write_regs is None:
            write_regs = []
        avail = (all(self.rf_info[r].can_read() for r in read_regs) and
                 all(self.rf_info[r].can_write() for r in write_regs))
        for reg in read_regs:
            if not self.rf_info[reg].can_read():
                logger.debug(f'Cannot read {self.rf_info[reg].name}')
        for reg in write_regs:
            if not self.rf_info[reg].can_write():
                logger.debug(f'Cannot write {self.rf_info[reg].name}')
        return avail

    async def wait_for_rf_available(self, read_regs=None, write_regs=None):
        while not self.rf_available(read_regs, write_regs):
            await self.clock.next_cycle

    def update(self):
        self._instruction_queue.update()
        self._instr_send_queue.update()
        self.cache_table.update()
        for jamlet in self.jamlets:
            jamlet.update()

    @property
    def k_index(self):
        return self.min_y // self.params.j_rows * self.params.k_cols + self.min_x // self.params.j_cols

    def get_jamlet(self, x, y):
        assert self.min_x <= x < self.min_x + self.n_columns
        assert self.min_y <= y < self.min_y + self.n_rows
        jamlet = self.jamlets[(y - self.min_y) * self.n_columns + (x - self.min_x)]
        assert jamlet.x == x
        assert jamlet.y == y
        return jamlet

    def add_to_instruction_queue(self, instr: kinstructions.KInstr):
        assert isinstance(instr, kinstructions.KInstr)
        self._instruction_queue.append(instr)

    async def _run_instructions(self):
        while True:
            await self.clock.next_cycle
            # If we have an instruction then do it
            if self._instruction_queue:
                self.available_instruction_tokens += 1
                instruction = self._instruction_queue.popleft()
                logger.warning(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: running {instruction}')
                await instruction.update_kamlet(self)
                logger.warning(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: finished instruction')

    def take_instruction_token(self):
        assert self.available_instruction_tokens > 0
        self.available_instruction_tokens -= 1

    async def _monitor_cache_requests(self):
        while True:
            await self.clock.next_cycle
            for request in self.cache_table.cache_requests:
                if request is None:
                    continue
                if not all(request.sent):
                    if request.request_type == CacheRequestType.READ_LINE:
                        logger.warning(f'{self.clock.cycle}: ***********************READING A CACHE LINE')
                        await self.read_cache_line(cache_slot=request.slot, address_in_memory=request.addr, ident=request.ident)
                        self.cache_table.report_sent_request(request)
                    else:
                        # Don't do anything for WRITE_LINE or WRITE_LINE_READ_LINE
                        # since those messages are sent at the jamlet level.
                        pass

    async def _get_instructions_from_jamlets(self):
        while True:
            await self.clock.next_cycle
            # Get received instructions from jamlets
            for index, jamlet in enumerate(self.jamlets):
                if jamlet._instruction_buffer:
                    if index == 0:
                        logger.warning('Got an instruction from jamlet')
                        if self._instruction_queue.can_append():
                            instr = jamlet._instruction_buffer.popleft()
                            logger.warning(f'Adding {type(instr)} to queue')
                            self.add_to_instruction_queue(instr)
                    else:
                        instr = jamlet._instruction_buffer.popleft()

    async def run(self):
        for jamlet in self.jamlets:
            self.clock.create_task(jamlet.run())
        self.clock.create_task(self._run_instructions())
        self.clock.create_task(self._send_packets())
        self.clock.create_task(self._get_instructions_from_jamlets())
        self.clock.create_task(self._monitor_cache_requests())
        self.clock.create_task(self._monitor_items())
        self.clock.create_task(self.cache_table.run())

    async def read_cache_line(self, cache_slot: int, address_in_memory: int, ident: int):
        """
        Reads from memory into the cache line.
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        logger.warning('Reading cache line')
        address_in_sram = cache_slot * self.params.cache_line_bytes // self.params.j_in_k

        header = AddressHeader(
            message_type=MessageType.READ_LINE, #4
            send_type=SendType.SINGLE,          #1
            target_x=self.mem_x,                #8
            target_y=self.mem_y,                #8
            source_x=self.min_x,                #8
            source_y=self.min_y,                #8
            address=address_in_sram,            #12
            length=2,                           #5
            ident=ident,               #5 bits
            )
        packet = [header, address_in_memory]

        while not self._instr_send_queue.can_append():
            await self.clock.next_cycle
        logger.warning('***************** sending read line packet')
        self._instr_send_queue.append(packet)

    async def handle_write_imm_bytes_instr(self, instr: kinstructions.WriteImmBytes):
        """
        Writes bytes to memory.
        They must all be within one word.
        It first makes sure that we've got the cache line ready.
        """
        logger.warning(f'{self.clock.cycle}: {(self.min_x, self.min_y)}: handle_write_imm_bytes_instr: {hex(instr.k_maddr.addr)}')
        if not self.cache_table.can_write(instr.k_maddr):
            logger.warning('******************** Adding write imm bytes item')
            await self.cache_table.add_item(
                    witem_type=WItemType.WRITE_IMM_BYTES, new_item=instr, protocol_states=[], k_maddr=instr.k_maddr,
                    cache_is_write=True)
        else:
            self.handle_write_imm_bytes_instr_final(instr)

    def handle_write_imm_bytes_instr_item(self, item: WaitingItem):
        """
        The cache line is ready and now we're processing the waiting item for the this instruction.
        """
        instr = item.item
        assert isinstance(instr, kinstructions.WriteImmBytes)
        self.handle_write_imm_bytes_instr_final(instr)

    def handle_write_imm_bytes_instr_final(self, instr: kinstructions.WriteImmBytes):
        """
        Update the cache line for the WriteImmBytes instruction.
        """
        logger.warning('Got cache. Updated jamlet sram')
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_write(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            size = len(instr.imm)
            jamlet.sram[j_saddr.addr: j_saddr.addr+size] = instr.imm

    async def handle_read_byte_instr(self, instr: kinstructions.ReadByte):
        logger.warning('kamlet: handle_ready_bytes_instr')
        if not self.cache_table.can_read(instr.k_maddr):
            await self.cache_table.add_item(witem_type=WItemType.READ_BYTE, new_item=instr, k_maddr=instr.k_maddr)
        else:
            await self.handle_read_byte_instr_final(instr=instr)

    async def handle_read_byte_instr_final(self, instr: kinstructions.ReadByte):
        logger.warning('We handling the read. The cache should be updated')
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_read(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            await jamlet.handle_read_byte_instr(instr, j_saddr.addr)

    async def handle_load_byte_instr(self, instr: kinstructions.LoadByte):
        raise NotImplementedError()

    async def handle_load_word_instr(self, instr: kinstructions.LoadWord):
        raise NotImplementedError()

    #
    #  Dealing with Load instruction
    #

    async def handle_load_instr(self, instr: kinstructions.Load):
        """
        When we receive a load:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)}')
        ew_match = instr.dst_ordering.ew == instr.k_maddr.ordering.ew
        aligned = (instr.k_maddr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        if ew_match and aligned:
            await self.handle_load_instr_simple(instr)
        else:
            await self.handle_load_instr_notsimple(instr)

    async def handle_load_instr_simple_item(self, item: WaitingItem):
        assert item.witem_type == WItemType.LOAD_SIMPLE
        assert isinstance(item.item, kinstructions.Load)
        # We've loaded the data into the cache.
        # Now we just need to process it.
        assert item.rf_ident is not None
        self.handle_load_instr_simple_final(item.item, item.rf_ident)

    async def handle_load_instr_simple(self, instr: kinstructions.Load) -> None:
        rf_write_ident = self.rf_info[instr.dst].start_write()
        if self.cache_table.can_read(instr.k_maddr):
            self.handle_load_instr_simple_final(instr, rf_write_ident)
        else:
            # It's not in cache.
            # We need to load it from memory first.
            slot = self.cache_table.addr_to_slot(instr.k_maddr)
            await self.cache_table.add_item(
                    witem_type=WItemType.LOAD_SIMPLE, new_item=instr,
                    k_maddr=instr.k_maddr, rf_ident=rf_write_ident)

    def handle_load_instr_simple_final(self, instr: kinstructions.Load, rf_ident: int) -> None:
        assert isinstance(instr, kinstructions.Load)
        assert self.cache_table.can_read(instr.k_maddr)
        # It's in cache. Update the jamlet register files immediately.
        for jamlet in self.jamlets:
            jamlet.handle_load_instr_simple(instr)
        self.rf_info[instr.dst].finish_write(rf_ident)

    async def handle_load_instr_notsimple(self, instr: kinstructions.Load) -> None:
        rf_write_ident = self.rf_info[instr.dst].start_write()
        await self.cache_table.add_item(
                witem_type=WItemType.LOAD_J2J_WORDS, new_item=instr,
                k_maddr=instr.k_maddr, rf_ident=rf_write_ident)
        tasks = []
        for jamlet in self.jamlets:
            tasks.append(jamlet.handle_load_j2j_words(instr))
        for task in tasks:
            await task

    async def handle_load_instr_notsimple_item(self, item: WaitingItem):
        assert item.witem_type == WItemType.LOAD_J2J_WORDS
        assert isinstance(item.item, kinstructions.Load)
        for pstate in item.protocol_states:
            pstate.finished()
        # We've loaded the data into the cache.
        # Now we just need to process it.
        assert item.rf_ident is not None
        self.rf_info[item.item.dst].finish_write(item.rf_ident)

    #
    #  Dealing with Store instruction
    #

    async def handle_store_instr(self, instr: kinstructions.Store):
        """
        When we receive a store:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')
        ew_match = instr.src_ordering.ew == instr.k_maddr.ordering.ew
        aligned = (instr.k_maddr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        if ew_match and aligned:
            await self.handle_store_instr_simple(instr)
        else:
            await self.handle_store_instr_notsimple(instr)

    async def handle_store_instr_simple(self, instr: kinstructions.Store) -> None:
        rf_read_ident = self.rf_info[instr.src].start_read()
        if self.cache_table.can_read(instr.k_maddr):
            self.handle_store_instr_simple_final(instr, rf_read_ident)
        else:
            # It's not in cache.
            # We need to load it from memory first.
            slot = self.cache_table.addr_to_slot(instr.k_maddr)
            await self.cache_table.add_item(
                    witem_type=WItemType.LOAD_SIMPLE, new_item=instr,
                    k_maddr=instr.k_maddr, rf_ident=rf_read_ident)

    async def handle_store_instr_simple_item(self, item: WaitingItem):
        assert item.witem_type == WItemType.STORE_SIMPLE
        assert isinstance(item.item, kinstructions.Store)
        # We've loaded the data into the cache.
        # Now we just need to process it.
        assert item.rf_ident is not None
        self.handle_store_instr_simple_final(item.item, item.rf_ident)

    def handle_store_instr_simple_final(self, instr: kinstructions.Store, rf_ident: int) -> None:
        assert isinstance(instr, kinstructions.Store)
        assert self.cache_table.can_write(instr.k_maddr)
        # It's in cache. Update the jamlet register files immediately.
        for jamlet in self.jamlets:
            jamlet.handle_store_instr_simple(instr)
        self.rf_info[instr.src].finish_read(rf_ident)

    async def handle_store_instr_notsimple(self, instr: kinstructions.Store) -> None:
        rf_read_ident = self.rf_info[instr.src].start_read()
        await self.cache_table.add_item(
                witem_type=WItemType.STORE_J2J_WORDS, new_item=instr,
                k_maddr=instr.k_maddr, rf_ident=rf_read_ident)
        tasks = []
        for jamlet in self.jamlets:
            tasks.append(jamlet.handle_store_j2j_words(instr))
        for task in tasks:
            await task

    async def handle_store_instr_notsimple_item(self, item: WaitingItem):
        assert item.witem_type == WItemType.STORE_J2J_WORDS
        assert isinstance(item.item, kinstructions.Store)
        for pstate in item.protocol_states:
            pstate.finished()
        # We've loaded the data into the cache.
        # Now we just need to process it.
        assert item.rf_ident is not None
        self.rf_info[item.item.src].finish_read(item.rf_ident)


    #async def handle_load_instr_cache_line(self, instr: kinstructions.Load):
    #    """
    #    Handle a load instruction.
    #    Data is already in the cache.
    #    """
    #    # Work out where this data needs to go.

    #    ## Check that the address is aligned to a vector line.
    #    #assert instr.k_maddr.k_index == 0
    #    #assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

    #    # Make sure that we have all the cache lines that we need for reading.
    #    futures = []
    #    for vline_index in range(n_vlines):
    #        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering,
    #                         bit_addr=m_addr*8, params=self.params)
    #        # We register our desire to read each vline independently since they
    #        # may be on different cache lines.
    #        write_token = self.rf_info[instr.dst + vline_index].start_write()
    #        if instr.mask_reg is not None:
    #            read_token = self.rf_info[instr.mask_reg].start_read()
    #        else:
    #            read_token = None
    #        coro = self._handle_load_instr_resolve(instr, vline_index, write_token, read_token)
    #        futures.append(await self.cache_table.request_read(k_maddr, coro))

    #    combined_future = self.clock.create_future()
    #    self.clock.create_task(utils.combine_futures(combined_future, futures))
    #    logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)} done')
    #    return combined_future

    def get_is_active(self, n_elements, element_width, word_order, mask_reg, vline_index, j_in_k_index, index_in_j):
        wb = self.params.word_bytes
        eb = element_width // 8
        elements_in_vline = self.params.vline_bytes*8//element_width
        jamlet = self.jamlets[j_in_k_index]
        vw_index = addresses.k_indices_to_vw_index(
                self.params, word_order, self.k_index, j_in_k_index)
        element_index = vline_index*elements_in_vline + index_in_j * self.params.j_in_l + vw_index
        valid_element = element_index < n_elements
        if mask_reg is not None:
            mask_bit_addr = mask_reg * wb * 8 + vline_index * (wb//eb) + index_in_j
            mask_byte = jamlet.rf_slice[mask_bit_addr//8]
            mask_bit = (mask_byte >> (mask_bit_addr % 8)) & 1
        else:
            mask_bit = 1
        return valid_element, mask_bit

    #async def _handle_load_instr_resolve(self, instr, vline_index, write_token, read_token):
    #    # This handles just one vline worth of data.
    #    # This guarantees that it will all be in the same cache line
    #    logger.info(f'kamlet ({self.min_x} {self.min_y}): _handle_load_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index} mask_reg={instr.mask_reg}')
    #    wb = self.params.word_bytes
    #    eb = instr.element_width//8
    #    m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #    k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
    #    j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
    #    assert instr.element_width % 8 == 0
    #    assert self.cache_table.can_read(k_maddr)
    #    mask_values = []
    #    valids = []
    #    old_values = []
    #    new_values = []
    #    loaded_values = []
    #    for j_in_k_index, jamlet in enumerate(self.jamlets):
    #        for index_in_j in range(wb//eb):
    #            valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
    #                                        instr.mask_reg,  vline_index, j_in_k_index, index_in_j)
    #            active = valid_element and mask_bit
    #            base_rf_addr = instr.dst*wb + vline_index*wb + index_in_j*eb
    #            base_sram_addr = j_saddr.addr + index_in_j*eb
    #            old_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
    #            if active:
    #                jamlet.rf_slice[base_rf_addr: base_rf_addr + eb] = jamlet.sram[base_sram_addr: base_sram_addr + eb]
    #            loaded_values.append(int.from_bytes(jamlet.sram[base_sram_addr: base_sram_addr + eb], byteorder='little'))
    #            new_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
    #            mask_values.append(mask_bit)
    #            valids.append(valid_element)
    #    self.rf_info[instr.dst + vline_index].finish_write(write_token)
    #    if read_token is not None:
    #        self.rf_info[instr.mask_reg].finish_read(read_token)
    #    logger.info(f'kamlet: _handle_load_instr_resolve, base rf address={instr.dst*wb + vline_index*wb} masks are is {mask_values} valids are {valids} old_values {old_values} loaded_values = {loaded_values} new_values {new_values}')

    #async def handle_store_instr(self, instr: kinstructions.Store):
    #    logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')

    #    assert instr.element_width == instr.k_maddr.ordering.ew
    #    vline_bits = self.params.vline_bytes * 8
    #    n_vlines = (instr.n_elements * instr.element_width + vline_bits)//vline_bits

    #    read_regs = [instr.src+index for index in range(n_vlines)]
    #    if instr.mask_reg is not None:
    #        read_regs.append(instr.mask_reg)
    #    await self.wait_for_rf_available(read_regs=read_regs)

    #    # Check that the address is aligned to a vector line.
    #    assert instr.k_maddr.k_index == 0
    #    assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

    #    # Make sure that we have all the cache lines that we need for writing.
    #    futures = []
    #    for vline_index in range(n_vlines):
    #        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
    #        # We register our desire to write each vline independently since they
    #        # may be on different cache lines.
    #        read_tokens = [self.rf_info[instr.src+vline_index].start_read()]
    #        if instr.mask_reg is not None:
    #            read_tokens.append(self.rf_info[instr.mask_reg].start_read())
    #        coro = self._handle_store_instr_resolve(instr, vline_index, read_tokens)
    #        futures.append(await self.cache_table.request_write(k_maddr, coro))

    #    combined_future = self.clock.create_future()
    #    self.clock.create_task(utils.combine_futures(combined_future, futures))
    #    return combined_future

    #async def _handle_store_instr_resolve(self, instr, vline_index, read_tokens):
    #    # This handles just one vline worth of data.
    #    # This guarantees that it will all be in the same cache line
    #    logger.info(f'kamlet: _handle_store_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index}, mask_reg is {instr.mask_reg}')
    #    wb = self.params.word_bytes
    #    eb = instr.element_width//8
    #    m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #    k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
    #    j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
    #    assert instr.element_width % 8 == 0
    #    assert self.cache_table.can_write(k_maddr)
    #    mask_values = []
    #    for index_in_j in range(wb//eb):
    #        for j_in_k_index, jamlet in enumerate(self.jamlets):
    #            valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
    #                                        instr.mask_reg, vline_index, j_in_k_index, index_in_j)
    #            if valid_element and mask_bit:
    #                base_rf_addr = instr.src*wb + vline_index*wb + index_in_j*eb
    #                base_sram_addr = j_saddr.addr + index_in_j*eb
    #                jamlet.sram[base_sram_addr: base_sram_addr + eb] = jamlet.rf_slice[base_rf_addr: base_rf_addr + eb]
    #            mask_values.append(mask_bit)
    #    self.rf_info[instr.src + vline_index].finish_read(read_tokens[0])
    #    if len(read_tokens) > 1:
    #        self.rf_info[instr.mask_reg].finish_read(read_tokens[1])
    #    logger.info(f'kamlet: _handle_store_instr_resolve, masks are is {mask_values}')

    #async def handle_read_reg_element_instr(self, instr: kinstructions.ReadRegElement):
    #    """Handle reading an element from vector register."""
    #    logger.debug(f'kamlet: handle_read_reg_element_instr src=v{instr.src} element={instr.element_index}')
    #    await self.wait_for_rf_available(read_regs=[instr.src])

    #    params = self.params
    #    vreg_bytes_per_jamlet = params.maxvl_bytes // params.j_in_l
    #    eb = instr.element_width // 8

    #    # Calculate which jamlet and offset within that jamlet
    #    vw_index = instr.element_index % params.j_in_l
    #    k_index, j_in_k_index = addresses.vw_index_to_k_indices(params, addresses.WordOrder.STANDARD, vw_index)
    #    element_in_jamlet = instr.element_index // params.j_in_l

    #    if k_index == self.k_index:
    #        jamlet = self.jamlets[j_in_k_index]
    #        src_offset = instr.src * vreg_bytes_per_jamlet + element_in_jamlet * eb
    #        value_bytes = bytes(jamlet.rf_slice[src_offset:src_offset + eb])

    #        # Send response message back to lamlet
    #        header = Header(
    #            message_type=MessageType.READ_BYTES_RESP,
    #            send_type=SendType.SINGLE,
    #            value=value_bytes,
    #            target_x=jamlet.front_x,
    #            target_y=jamlet.front_y,
    #            source_x=jamlet.x,
    #            source_y=jamlet.y,
    #            address=None,
    #            length=1,
    #            ident=instr.ident,
    #        )
    #        packet = [header]
    #        send_queue = jamlet.send_queues[header.message_type]
    #        while not send_queue.can_append():
    #            await self.clock.next_cycle
    #        send_queue.append(packet)

    async def handle_item(self, item: WaitingItem) -> None:
        if item.witem_type == WItemType.WRITE_IMM_BYTES:
            self.handle_write_imm_bytes_instr_item(item)
        elif item.witem_type == WItemType.READ_BYTE:
            await self.handle_read_byte_instr_final(item.item)
        elif item.witem_type == WItemType.LOAD_SIMPLE:
            await self.handle_load_instr_simple_item(item=item)
        elif item.witem_type == WItemType.STORE_SIMPLE:
            await self.handle_store_instr_simple_item(item=item)
        elif item.witem_type == WItemType.LOAD_J2J_WORDS:
            await self.handle_load_instr_notsimple_item(item=item)
        elif item.witem_type == WItemType.STORE_J2J_WORDS:
            await self.handle_store_instr_notsimple_item(item=item)
        else:
            raise NotImplementedError()

    async def _monitor_items(self) -> None:
        while True:
            await self.clock.next_cycle
            for index, item in enumerate(self.cache_table.waiting_items):
                if item is None:
                    continue
                if (all(x.finished() for x in item.protocol_states) and item.cache_slot is None
                        or item.cache_is_avail):
                    self.cache_table.waiting_items[index] = None
                    await self.handle_item(item)

    async def _send_packets(self) -> None:
        while True:
            await self.clock.next_cycle
            if self._instr_send_queue:
                packet = self._instr_send_queue.popleft()
                buffer = self.jamlets[SEND_READ_LINE_J_INDEX].send_queues[packet[0].message_type]
                while not buffer.can_append():
                    await self.clock.next_cycle
                buffer.append(packet)
