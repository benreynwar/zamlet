import logging

from cache_table import CacheTable
import addresses
from addresses import KMAddr
from params import LamletParams
from jamlet import Jamlet
from message import Header, MessageType, SendType
from utils import Queue
import kinstructions
import memlet
from response_tracker import ResponseTracker
import utils
import register_file_slot


logger = logging.getLogger(__name__)


SEND_READ_LINE_J_INDEX = 1


class Kamlet:
    """
    A collection of lanes.
    They share an instruction buffer, and cache tracking logic.
    """

    def __init__(self, clock, params: LamletParams, min_x: int, min_y: int):
        self.clock = clock
        self.params = params

        # A kamlet covers several (x,y) coordinate positions (one for each lane (jamlet))
        self.min_x = min_x
        self.min_y = min_y
        self.n_columns = params.j_cols
        self.n_rows = params.j_rows
        self.n_jamlets = self.n_columns * self.n_rows

        k_x = self.min_x//params.j_cols
        k_y = self.min_y//params.j_rows
        k_index = k_y * params.k_cols + k_x
        mem_coords = memlet.m_router_coords(params, k_index, 0)
        self.mem_x = mem_coords[0]
        self.mem_y = mem_coords[1]

        self.available_instruction_tokens = self.params.instruction_queue_length

        # We pass methods to the cache table to flush and read lines.
        name = f'CacheTable ({self.min_x}, {self.min_y})'
        self.cache_table = CacheTable(clock, params, self.write_cache_line, self.read_cache_line, name)

        # Keeps track of the messages that we've sent where we
        # are expecting a response.
        self.response_tracker = ResponseTracker(clock, params)

        self.jamlets = []
        for index in range(self.n_jamlets):
            x = min_x+index % self.n_columns
            y = min_y+index//self.n_columns
            self.jamlets.append(Jamlet(clock, params, x, y, self.response_tracker))

        # Local State
        self._instruction_queue = Queue(self.params.instruction_queue_length)

        # We place packets here that are generated by instructions.
        self._instr_send_queue = Queue(2)

        self.rf_info = [register_file_slot.KamletRegisterFileSlot(f'v{index}') for _ in range(self.params.n_vregs)]

    def rf_available(self, read_regs=None, write_regs=None):
        if read_regs is None:
            read_regs = []
        if write_regs is None:
            write_regs = []
        avail = (all(self.rf_info[r].can_read() for r in read_regs) and
                 all(self.rf_info[r].can_write() for r in write_regs))
        for reg in read_regs:
            if not self.rf_info[reg].can_read():
                logger.debug(f'Cannot read {self.rf_info[reg].name}')
        for reg in write_regs:
            if not self.rf_info[reg].can_write():
                logger.debug(f'Cannot write {self.rf_info[reg].name}')
        return avail

    async def wait_for_rf_available(self, read_regs=None, write_regs=None):
        while not self.rf_available(read_regs, write_regs):
            await self.clock.next_cycle

    def update(self):
        self._instruction_queue.update()
        self._instr_send_queue.update()
        for jamlet in self.jamlets:
            jamlet.update()

    @property
    def k_index(self):
        return self.min_y // self.params.j_rows * self.params.k_cols + self.min_x // self.params.j_cols

    def get_jamlet(self, x, y):
        assert self.min_x <= x < self.min_x + self.n_columns
        assert self.min_y <= y < self.min_y + self.n_rows
        jamlet = self.jamlets[(y - self.min_y) * self.n_columns + (x - self.min_x)]
        assert jamlet.x == x
        assert jamlet.y == y
        return jamlet

    def add_to_instruction_queue(self, instr: kinstructions.KInstr):
        assert isinstance(instr, kinstructions.KInstr)
        self._instruction_queue.append(instr)

    async def _run_instructions(self):
        while True:
            await self.clock.next_cycle
            # If we have an instruction then do it
            if self._instruction_queue:
                self.available_instruction_tokens += 1
                instruction = self._instruction_queue.popleft()
                logger.debug(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: running {instruction}')
                await instruction.update_kamlet(self)

    def take_instruction_token(self):
        assert self.available_instruction_tokens > 0
        self.available_instruction_tokens -= 1

    async def run(self):
        for jamlet in self.jamlets:
            self.clock.create_task(jamlet.run())
        self.clock.create_task(self._run_instructions())
        self.clock.create_task(self._send_packets())
        while True:
            await self.clock.next_cycle
            # Get received instructions from jamlets
            for index, jamlet in enumerate(self.jamlets):
                if jamlet._instruction_buffer:
                    if index == 0:
                        if self._instruction_queue.can_append():
                            instr = jamlet._instruction_buffer.popleft()
                            self.add_to_instruction_queue(instr)
                    else:
                        instr = jamlet._instruction_buffer.popleft()

    async def read_cache_line(self, cache_slot: int, address_in_memory: int):
        """
        Reads from memory into the cache line.
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        address_in_sram = cache_slot * self.params.cache_line_bytes // self.params.j_in_k
        # Here we're registering what callback we'll use for each received response based on the
        # target of the received packet.
        dest_to_method = {(jamlet.x, jamlet.y): jamlet.read_cache_line_resolve for jamlet in self.jamlets}
        label = ('READ_LINE', address_in_memory)
        response_ident, dest_to_futures = await self.response_tracker.register_dsts(dest_to_method, label)

        header = Header(
            message_type=MessageType.READ_LINE, #4
            send_type=SendType.SINGLE,          #1
            target_x=self.mem_x,                #8
            target_y=self.mem_y,                #8
            source_x=self.min_x,                #8
            source_y=self.min_y,                #8
            address=address_in_sram,            #12
            length=2,                           #5
            ident=response_ident,               #5 bits
            )
        packet = [header, address_in_memory]

        while not self._instr_send_queue.can_append():
            await self.clock.next_cycle
        self._instr_send_queue.append(packet)

        # Create a future that will resolve when all of the jamlet callbacks have completed.
        combined_future = self.clock.create_future()
        futures = list(dest_to_futures.values())
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        return combined_future

    async def write_cache_line(self, cache_slot: int, address_in_memory: int):
        """
        Write from cache line into the memory
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        label = ('WRITE_LINE', (self.min_x, self.min_y), address_in_memory)
        response_ident, futures = await self.response_tracker.register_count([None], label)
        future = futures[0]
        tasks = []
        for jamlet in self.jamlets:
            # Create tasks so these jamlets can run in parallel.
            tasks.append(self.clock.create_task(jamlet.write_cache_line(cache_slot, address_in_memory, response_ident)))
        # Block until the jamlets all send the packets.
        for task in tasks:
            await task
        return future

    async def handle_write_imm_bytes_instr(self, instr: kinstructions.WriteImmBytes):
        """
        Writes bytes to memory.
        They must all be within one word.
        """
        logger.debug(f'{self.clock.cycle}: {(self.min_x, self.min_y)}: handle_write_imm_bytes_instr: {hex(instr.k_maddr.addr)}')
        # This is the corouine that will do the writing.
        coro = self._handle_write_imm_bytes_instr_resolve(instr)
        # But we don't actually run it until we have the cache ready.
        future = await self.cache_table.request_write(instr.k_maddr, coro)
        return future

    async def _handle_write_imm_bytes_instr_resolve(self, instr: kinstructions.WriteImmBytes):
        # Now we can write to the cache.
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_write(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.params, self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            size = len(instr.imm)
            jamlet.sram[j_saddr.addr: j_saddr.addr+size] = instr.imm

    async def handle_read_bytes_instr(self, instr: kinstructions.ReadBytes):
        logger.debug('kamlet: handle_ready_bytes_instr')
        # This is the corouine that will do the writing.
        coro = self._handle_read_bytes_instr_resolve(instr)
        # But we don't actually run it until we have the cache ready.
        future = await self.cache_table.request_read(instr.k_maddr, coro)
        return future

    async def _handle_read_bytes_instr_resolve(self, instr: kinstructions.WriteImmBytes):
        logger.debug('We handling the read. The cache should be updated')
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_read(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.params, self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            future = await jamlet.handle_read_bytes_instr(instr, j_saddr.addr)

    async def handle_load_instr(self, instr: kinstructions.Load):
        logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)}')
        assert instr.element_width == instr.k_maddr.ordering.ew
        vline_bits = self.params.vline_bytes * 8
        n_vlines = (instr.n_elements * instr.element_width + vline_bits)//vline_bits
        elements_in_vline = vline_bits//instr.element_width

        write_regs = [instr.dst+index for index in range(n_vlines)]
        if instr.mask_reg is not None:
            read_regs = [instr.mask_reg]
        else:
            read_regs = []
        await self.wait_for_rf_available(write_regs=write_regs, read_regs=read_regs)

        # Check that the address is aligned to a vector line.
        assert instr.k_maddr.k_index == 0
        assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

        # Make sure that we have all the cache lines that we need for reading.
        futures = []
        for vline_index in range(n_vlines):
            m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
            k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
            # We register our desire to read each vline independently since they
            # may be on different cache lines.
            write_token = self.rf_info[instr.dst + vline_index].start_write()
            if instr.mask_reg is not None:
                read_token = self.rf_info[instr.mask_reg].start_read()
            else:
                read_token = None
            coro = self._handle_load_instr_resolve(instr, vline_index, write_token, read_token)
            futures.append(await self.cache_table.request_read(k_maddr, coro))

        combined_future = self.clock.create_future()
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)} done')
        return combined_future

    def get_is_active(self, n_elements, element_width, word_order, mask_reg, vline_index, j_in_k_index, index_in_j):
        wb = self.params.word_bytes
        eb = element_width // 8
        elements_in_vline = self.params.vline_bytes*8//element_width
        jamlet = self.jamlets[j_in_k_index]
        vw_index = addresses.k_indices_to_vw_index(
                self.params, word_order, self.k_index, j_in_k_index)
        element_index = vline_index*elements_in_vline + index_in_j * self.params.j_in_l + vw_index
        valid_element = element_index < n_elements
        if mask_reg is not None:
            mask_bit_addr = mask_reg * wb * 8 + vline_index * (wb//eb) + index_in_j
            mask_byte = jamlet.rf_slice[mask_bit_addr//8]
            mask_bit = (mask_byte >> (mask_bit_addr % 8)) & 1
        else:
            mask_bit = 1
        return valid_element, mask_bit

    async def _handle_load_instr_resolve(self, instr, vline_index, write_token, read_token):
        # This handles just one vline worth of data.
        # This guarantees that it will all be in the same cache line
        logger.info(f'kamlet ({self.min_x} {self.min_y}): _handle_load_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index} mask_reg={instr.mask_reg}')
        wb = self.params.word_bytes
        eb = instr.element_width//8
        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
        j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
        assert instr.element_width % 8 == 0
        assert self.cache_table.can_read(k_maddr)
        mask_values = []
        valids = []
        old_values = []
        new_values = []
        loaded_values = []
        for j_in_k_index, jamlet in enumerate(self.jamlets):
            for index_in_j in range(wb//eb):
                valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
                                            instr.mask_reg,  vline_index, j_in_k_index, index_in_j)
                active = valid_element and mask_bit
                base_rf_addr = instr.dst*wb + vline_index*wb + index_in_j*eb
                base_sram_addr = j_saddr.addr + index_in_j*eb
                old_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
                if active:
                    jamlet.rf_slice[base_rf_addr: base_rf_addr + eb] = jamlet.sram[base_sram_addr: base_sram_addr + eb]
                loaded_values.append(int.from_bytes(jamlet.sram[base_sram_addr: base_sram_addr + eb], byteorder='little'))
                new_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
                mask_values.append(mask_bit)
                valids.append(valid_element)
        self.rf_info[instr.dst + vline_index].finish_write(write_token)
        if read_token is not None:
            self.rf_info[instr.mask_reg].finish_read(read_token)
        logger.info(f'kamlet: _handle_load_instr_resolve, base rf address={instr.dst*wb + vline_index*wb} masks are is {mask_values} valids are {valids} old_values {old_values} loaded_values = {loaded_values} new_values {new_values}')

    async def handle_store_instr(self, instr: kinstructions.Store):
        logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')

        assert instr.element_width == instr.k_maddr.ordering.ew
        vline_bits = self.params.vline_bytes * 8
        n_vlines = (instr.n_elements * instr.element_width + vline_bits)//vline_bits

        read_regs = [instr.src+index for index in range(n_vlines)]
        if instr.mask_reg is not None:
            read_regs.append(instr.mask_reg)
        await self.wait_for_rf_available(read_regs=read_regs)

        # Check that the address is aligned to a vector line.
        assert instr.k_maddr.k_index == 0
        assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

        # Make sure that we have all the cache lines that we need for writing.
        futures = []
        for vline_index in range(n_vlines):
            m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
            k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
            # We register our desire to write each vline independently since they
            # may be on different cache lines.
            read_tokens = [self.rf_info[instr.src+vline_index].start_read()]
            if instr.mask_reg is not None:
                read_tokens.append(self.rf_info[instr.mask_reg].start_read())
            coro = self._handle_store_instr_resolve(instr, vline_index, read_tokens)
            futures.append(await self.cache_table.request_write(k_maddr, coro))

        combined_future = self.clock.create_future()
        self.clock.create_task(utils.combine_futures(combined_future, futures))
        return combined_future

    async def _handle_store_instr_resolve(self, instr, vline_index, read_tokens):
        # This handles just one vline worth of data.
        # This guarantees that it will all be in the same cache line
        logger.info(f'kamlet: _handle_store_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index}, mask_reg is {instr.mask_reg}')
        wb = self.params.word_bytes
        eb = instr.element_width//8
        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
        j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
        assert instr.element_width % 8 == 0
        assert self.cache_table.can_write(k_maddr)
        mask_values = []
        for index_in_j in range(wb//eb):
            for j_in_k_index, jamlet in enumerate(self.jamlets):
                valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
                                            instr.mask_reg, vline_index, j_in_k_index, index_in_j)
                if valid_element and mask_bit:
                    base_rf_addr = instr.src*wb + vline_index*wb + index_in_j*eb
                    base_sram_addr = j_saddr.addr + index_in_j*eb
                    jamlet.sram[base_sram_addr: base_sram_addr + eb] = jamlet.rf_slice[base_rf_addr: base_rf_addr + eb]
                mask_values.append(mask_bit)
        self.rf_info[instr.src + vline_index].finish_read(read_tokens[0])
        if len(read_tokens) > 1:
            self.rf_info[instr.mask_reg].finish_read(read_tokens[1])
        logger.info(f'kamlet: _handle_store_instr_resolve, masks are is {mask_values}')

    async def _send_packets(self):
        while True:
            await self.clock.next_cycle
            if self._instr_send_queue:
                packet = self._instr_send_queue.popleft()
                buffer = self.jamlets[SEND_READ_LINE_J_INDEX].send_queues[packet[0].message_type]
                while not buffer.can_append():
                    await self.clock.next_cycle
                buffer.append(packet)
