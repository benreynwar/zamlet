import logging
from typing import List

import addresses
from addresses import KMAddr
from params import LamletParams
from jamlet import Jamlet
from message import Header, MessageType, SendType, AddressHeader
from utils import Queue
import kinstructions
import memlet
import register_file_slot
import cache_table
from cache_table import CacheRequestType, CacheTable, WaitingItem, LoadSrcState, LoadDstState


logger = logging.getLogger(__name__)


SEND_READ_LINE_J_INDEX = 1


class Kamlet:
    """
    A collection of lanes.
    They share an instruction buffer, and cache tracking logic.
    """

    def __init__(self, clock, params: LamletParams, min_x: int, min_y: int):
        self.clock = clock
        self.params = params

        # A kamlet covers several (x,y) coordinate positions (one for each lane (jamlet))
        self.min_x = min_x
        self.min_y = min_y
        self.n_columns = params.j_cols
        self.n_rows = params.j_rows
        self.n_jamlets = self.n_columns * self.n_rows

        k_x = self.min_x//params.j_cols
        k_y = self.min_y//params.j_rows
        k_index = k_y * params.k_cols + k_x
        mem_coords = memlet.m_router_coords(params, k_index, 0)
        self.mem_x = mem_coords[0]
        self.mem_y = mem_coords[1]

        self.available_instruction_tokens = self.params.instruction_queue_length

        # We pass methods to the cache table to flush and read lines.
        name = f'CacheTable ({self.min_x}, {self.min_y})'
        self.cache_table = CacheTable(clock, params, name)
        self.rf_info = register_file_slot.KamletRegisterFile(self.params.n_vregs)

        self.jamlets = []
        for index in range(self.n_jamlets):
            x = min_x+index % self.n_columns
            y = min_y+index//self.n_columns
            self.jamlets.append(Jamlet(clock, params, x, y, self.cache_table, self.rf_info))

        # Local State
        self._instruction_queue = Queue(self.params.instruction_queue_length)

        # We place packets here that are generated by instructions.
        self._instr_send_queue = Queue(2)


    def rf_available(self, read_regs=None, write_regs=None):
        if read_regs is None:
            read_regs = []
        if write_regs is None:
            write_regs = []
        avail = (all(self.rf_info.can_read(r) for r in read_regs) and
                 all(self.rf_info.can_write(r) for r in write_regs))
        #for reg in read_regs:
        #    if not self.rf_info.can_read(reg):
        #        logger.debug(f'Cannot read {self.rf_info[reg].name}')
        #for reg in write_regs:
        #    if not self.rf_info.can_write(reg):
        #        logger.debug(f'Cannot write {self.rf_info[reg].name}')
        return avail

    async def wait_for_rf_available(self, read_regs=None, write_regs=None):
        while not self.rf_available(read_regs, write_regs):
            await self.clock.next_cycle

    def update(self):
        self._instruction_queue.update()
        self._instr_send_queue.update()
        self.cache_table.update()
        for jamlet in self.jamlets:
            jamlet.update()

    @property
    def k_index(self):
        return self.min_y // self.params.j_rows * self.params.k_cols + self.min_x // self.params.j_cols

    def get_regs(self, start_index: int, n_elements: int, base_reg: int, ew: int):
        '''
        Given a start_index and n_elements and a base register work out which vector registers
        get touched (in any kamlet, but that's good enough)
        '''
        elements_in_vline = self.params.vline_bytes * 8 // ew
        start_vline = start_index // elements_in_vline
        end_vline = (start_index + n_elements - 1) // elements_in_vline
        regs = [base_reg + vline_offset for vline_offset in range(start_vline, end_vline + 1)]
        return regs

    def get_jamlet(self, x, y):
        assert self.min_x <= x < self.min_x + self.n_columns
        assert self.min_y <= y < self.min_y + self.n_rows
        jamlet = self.jamlets[(y - self.min_y) * self.n_columns + (x - self.min_x)]
        assert jamlet.x == x
        assert jamlet.y == y
        return jamlet

    def add_to_instruction_queue(self, instr: kinstructions.KInstr):
        assert isinstance(instr, kinstructions.KInstr)
        self._instruction_queue.append(instr)

    async def _run_instructions(self):
        while True:
            await self.clock.next_cycle
            # If we have an instruction then do it
            if self._instruction_queue:
                self.available_instruction_tokens += 1
                instruction = self._instruction_queue.popleft()
                await instruction.update_kamlet(self)

    def take_instruction_token(self):
        assert self.available_instruction_tokens > 0
        self.available_instruction_tokens -= 1

    async def _monitor_cache_requests(self):
        while True:
            await self.clock.next_cycle
            for request in self.cache_table.cache_requests:
                if request is None:
                    continue
                if not all(request.sent):
                    if request.request_type == CacheRequestType.READ_LINE:
                        await self.read_cache_line(cache_slot=request.slot, address_in_memory=request.addr, ident=request.ident)
                        self.cache_table.report_sent_request(request)
                    else:
                        # Don't do anything for WRITE_LINE or WRITE_LINE_READ_LINE
                        # since those messages are sent at the jamlet level.
                        pass

    async def _get_instructions_from_jamlets(self):
        while True:
            await self.clock.next_cycle
            # Get received instructions from jamlets
            for index, jamlet in enumerate(self.jamlets):
                if jamlet._instruction_buffer:
                    if index == 0:
                        if self._instruction_queue.can_append():
                            instr = jamlet._instruction_buffer.popleft()
                            self.add_to_instruction_queue(instr)
                    else:
                        instr = jamlet._instruction_buffer.popleft()

    async def run(self):
        for jamlet in self.jamlets:
            self.clock.create_task(jamlet.run())
        self.clock.create_task(self._run_instructions())
        self.clock.create_task(self._send_packets())
        self.clock.create_task(self._get_instructions_from_jamlets())
        self.clock.create_task(self._monitor_cache_requests())
        self.clock.create_task(self._monitor_items())
        self.clock.create_task(self.cache_table.run())

    async def read_cache_line(self, cache_slot: int, address_in_memory: int, ident: int):
        """
        Reads from memory into the cache line.
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        logger.debug('{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: read_cache_line')
        address_in_sram = cache_slot * self.params.cache_line_bytes // self.params.j_in_k

        header = AddressHeader(
            message_type=MessageType.READ_LINE, #4
            send_type=SendType.SINGLE,          #1
            target_x=self.mem_x,                #8
            target_y=self.mem_y,                #8
            source_x=self.min_x,                #8
            source_y=self.min_y,                #8
            address=address_in_sram,            #12
            length=2,                           #5
            ident=ident,               #5 bits
            )
        assert address_in_memory % self.params.cache_line_bytes == 0
        packet = [header, address_in_memory]

        while not self._instr_send_queue.can_append():
            await self.clock.next_cycle
        self._instr_send_queue.append(packet)

    async def handle_write_imm_bytes_instr(self, instr: kinstructions.WriteImmBytes):
        """
        Writes bytes to memory.
        They must all be within one word.
        It first makes sure that we've got the cache line ready.
        """
        logger.debug(f'{self.clock.cycle}: {(self.min_x, self.min_y)}: handle_write_imm_bytes_instr: {hex(instr.k_maddr.addr)}')
        if not self.cache_table.can_write(instr.k_maddr):
            witem = cache_table.WaitingWriteImmBytes(instr)
            await self.cache_table.add_witem(witem, instr.k_maddr)
        else:
            self.handle_write_imm_bytes_instr_final(instr)

    def handle_write_imm_bytes_instr_witem(self, witem: WaitingItem):
        """
        The cache line is ready and now we're processing the waiting item for the this instruction.
        """
        instr = witem.item
        assert isinstance(instr, kinstructions.WriteImmBytes)
        self.handle_write_imm_bytes_instr_final(instr)

    def handle_write_imm_bytes_instr_final(self, instr: kinstructions.WriteImmBytes):
        """
        Update the cache line for the WriteImmBytes instruction.
        """
        logger.debug('handle_write_imm_bytes_instr_final: start')
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_write(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            size = len(instr.imm)
            jamlet.sram[j_saddr.addr: j_saddr.addr+size] = instr.imm

    async def handle_read_byte_instr(self, instr: kinstructions.ReadByte):
        logger.debug(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: handle_read_bytes_instr')
        if not self.cache_table.can_read(instr.k_maddr):
            witem = cache_table.WaitingReadByte(instr)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        else:
            await self.handle_read_byte_instr_final(instr=instr)

    async def handle_read_byte_instr_final(self, instr: kinstructions.ReadByte):
        logger.debug('handle_read_byte_instr_final')
        assert instr.k_maddr.bit_addr % 8 == 0
        if instr.k_maddr.k_index == self.k_index:
            assert self.cache_table.can_read(instr.k_maddr)
            j_saddr = instr.k_maddr.to_j_saddr(self.cache_table)
            jamlet = self.jamlets[j_saddr.j_in_k_index]
            await jamlet.handle_read_byte_instr(instr, j_saddr.addr)

    async def handle_load_byte_instr(self, instr: kinstructions.LoadByte):
        raise NotImplementedError()

    async def handle_load_word_instr(self, instr: kinstructions.LoadWord):
        """Handle LoadWord instruction - load partial word from cache to register."""
        is_src_kamlet = (instr.src.k_index == self.k_index)
        is_dst_kamlet = (instr.dst.k_index == self.k_index)

        logger.debug(
            f'kamlet ({self.min_x}, {self.min_y}): handle_load_word_instr '
            f'ident={instr.instr_ident} src_k={instr.src.k_index} '
            f'dst_k={instr.dst.k_index} is_src={is_src_kamlet} is_dst={is_dst_kamlet}')

        if not (is_src_kamlet or is_dst_kamlet):
            return

        if is_src_kamlet:
            witem_src = cache_table.WaitingLoadWordSrc(params=self.params, instr=instr)
            await self.cache_table.add_witem(witem=witem_src, k_maddr=instr.src)
            logger.warning(f'kamlet ({self.min_x}, {self.min_y}): added WaitingLoadWordSrc ident={witem_src.instr_ident}')
            for jamlet in self.jamlets:
                jamlet.init_load_word_src_state(witem_src)

        if is_dst_kamlet:
            logger.warning(f'kamlet ({self.min_x}, {self.min_y}): is waiting for rf {instr.dst.reg} to become avail')
            await self.wait_for_rf_available(write_regs=[instr.dst.reg])
            logger.warning(f'kamlet ({self.min_x}, {self.min_y}): rf {instr.dst.reg} is avail')
            rf_write_ident = self.rf_info.start_writes([instr.dst.reg])
            witem_dst = cache_table.WaitingLoadWordDst(params=self.params, instr=instr, rf_ident=rf_write_ident)
            await self.cache_table.add_witem(witem=witem_dst)
            logger.warning(f'kamlet ({self.min_x}, {self.min_y}): added WaitingLoadWordDst ident={witem_dst.instr_ident}')
            for jamlet in self.jamlets:
                jamlet.init_load_word_dst_state(witem_dst)

    async def handle_load_word_src_witem(self, witem: cache_table.WaitingLoadWordSrc):
        """Called when LoadWord SRC operation completes."""
        assert all(state == LoadSrcState.COMPLETE for state in witem.protocol_states)

    async def handle_load_word_dst_witem(self, witem: cache_table.WaitingLoadWordDst):
        """Called when LoadWord DST operation completes."""
        assert all(state == LoadDstState.COMPLETE for state in witem.protocol_states)
        assert witem.rf_ident is not None
        instr = witem.item
        self.rf_info.finish_writes([instr.dst.reg], witem.rf_ident)

    #
    #  Dealing with Load instruction
    #

    async def handle_load_instr(self, instr: kinstructions.Load):
        """
        When we receive a load:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        ew_match = instr.dst_ordering.ew == instr.k_maddr.ordering.ew
        physical_vline_addr = instr.k_maddr.to_physical_vline_addr()
        aligned = (physical_vline_addr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_instr addr={hex(instr.k_maddr.addr)} ew_match={ew_match} aligned={aligned} dst_ew={instr.dst_ordering.ew} mem_ew={instr.k_maddr.ordering.ew}')
        if ew_match and aligned:
            await self.handle_load_instr_simple(instr)
        else:
            await self.handle_load_instr_notsimple(instr)

    async def handle_load_instr_simple_witem(self, witem: WaitingItem):
        assert isinstance(witem, cache_table.WaitingLoadSimple)
        # We've loaded the data into the cache.
        # Now we just need to process it.
        assert witem.rf_ident is not None
        self.handle_load_instr_simple_final(witem.item, witem.rf_ident)

    async def handle_load_instr_simple(self, instr: kinstructions.Load) -> None:
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_instr_simple')
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        await self.wait_for_rf_available(write_regs=dst_regs)
        rf_write_ident = self.rf_info.start_writes(dst_regs)
        if self.cache_table.can_read(instr.k_maddr):
            self.handle_load_instr_simple_final(instr, rf_write_ident)
        else:
            # It's not in cache.
            # We need to load it from memory first.
            witem = cache_table.WaitingLoadSimple(instr=instr, rf_ident=rf_write_ident)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    def handle_load_instr_simple_final(self, instr: kinstructions.Load, rf_ident: int) -> None:
        assert isinstance(instr, kinstructions.Load)
        assert self.cache_table.can_read(instr.k_maddr)
        # It's in cache. Update the jamlet register files immediately.
        for jamlet in self.jamlets:
            jamlet.handle_load_instr_simple(instr)
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        self.rf_info.finish_writes(dst_regs, rf_ident)

    async def handle_load_instr_notsimple(self, instr: kinstructions.Load) -> None:
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_instr_notsimple addr={hex(instr.k_maddr.addr)} ident={instr.instr_ident}')
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        await self.wait_for_rf_available(write_regs=dst_regs)
        rf_write_ident = self.rf_info.start_writes(dst_regs)
        witem = cache_table.WaitingLoadJ2JWords(
                params=self.params, instr=instr, rf_ident=rf_write_ident)
        await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        instr = witem.item
        for jamlet in self.jamlets:
            for tag in range(instr.n_tags()):
                jamlet.init_load_j2j_words_dst_state(witem, tag)

    async def handle_load_instr_notsimple_witem(self, witem: cache_table.WaitingLoadJ2JWords):
        instr = witem.item
        for pstate in witem.protocol_states:
            assert pstate.finished()
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        assert witem.rf_ident is not None
        self.rf_info.finish_writes(dst_regs, witem.rf_ident)

    #
    #  Dealing with Store instruction
    #

    async def handle_store_instr(self, instr: kinstructions.Store):
        """
        When we receive a store:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')
        ew_match = instr.src_ordering.ew == instr.k_maddr.ordering.ew
        aligned = (instr.k_maddr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        if ew_match and aligned:
            await self.handle_store_instr_simple(instr)
        else:
            await self.handle_store_instr_notsimple(instr)

    async def handle_store_instr_simple(self, instr: kinstructions.Store) -> None:
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        await self.wait_for_rf_available(read_regs=src_regs)
        rf_read_ident = self.rf_info.start_reads(src_regs)
        if self.cache_table.can_read(instr.k_maddr):
            self.handle_store_instr_simple_final(instr, rf_read_ident)
        else:
            # It's not in cache.
            # We need to load it from memory first.
            witem = cache_table.WaitingStoreSimple(instr=instr, rf_ident=rf_read_ident)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    async def handle_store_instr_simple_witem(self, witem: WaitingItem):
        # We've loaded the data into the cache.
        # Now we just need to process it.
        assert witem.rf_ident is not None
        self.handle_store_instr_simple_final(witem.item, witem.rf_ident)

    def handle_store_instr_simple_final(self, instr: kinstructions.Store, rf_ident: int) -> None:
        assert isinstance(instr, kinstructions.Store)
        assert self.cache_table.can_write(instr.k_maddr)
        # It's in cache. Update the jamlet register files immediately.
        for jamlet in self.jamlets:
            jamlet.handle_store_instr_simple(instr)
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        self.rf_info.finish_reads(src_regs, rf_ident)

    async def handle_store_instr_notsimple(self, instr: kinstructions.Store) -> None:
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_store_instr_notsimple addr={hex(instr.k_maddr.addr)} ident={instr.instr_ident}')
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        await self.wait_for_rf_available(read_regs=src_regs)
        rf_read_ident = self.rf_info.start_reads(src_regs)
        witem = cache_table.WaitingStoreJ2JWords(
                params=self.params, instr=instr, rf_ident=rf_read_ident)
        await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        for jamlet in self.jamlets:
            for tag in range(instr.n_tags()):
                jamlet.init_store_j2j_words_dst_state(witem, tag)

    async def handle_store_instr_notsimple_witem(self, witem: cache_table.WaitingStoreJ2JWords):
        instr = witem.item
        for pstate in witem.protocol_states:
            assert pstate.finished()
        assert witem.rf_ident is not None
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        self.rf_info.finish_reads(src_regs, witem.rf_ident)


    #async def handle_load_instr_cache_line(self, instr: kinstructions.Load):
    #    """
    #    Handle a load instruction.
    #    Data is already in the cache.
    #    """
    #    # Work out where this data needs to go.

    #    ## Check that the address is aligned to a vector line.
    #    #assert instr.k_maddr.k_index == 0
    #    #assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

    #    # Make sure that we have all the cache lines that we need for reading.
    #    futures = []
    #    for vline_index in range(n_vlines):
    #        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering,
    #                         bit_addr=m_addr*8, params=self.params)
    #        # We register our desire to read each vline independently since they
    #        # may be on different cache lines.
    #        write_token = self.rf_info[instr.dst + vline_index].start_write()
    #        if instr.mask_reg is not None:
    #            read_token = self.rf_info[instr.mask_reg].start_read()
    #        else:
    #            read_token = None
    #        coro = self._handle_load_instr_resolve(instr, vline_index, write_token, read_token)
    #        futures.append(await self.cache_table.request_read(k_maddr, coro))

    #    combined_future = self.clock.create_future()
    #    self.clock.create_task(utils.combine_futures(combined_future, futures))
    #    logger.debug(f'kamlet: handle_load_instr {hex(instr.k_maddr.addr)} done')
    #    return combined_future

    def get_is_active(self, n_elements, element_width, word_order, mask_reg, vline_index, j_in_k_index, index_in_j):
        wb = self.params.word_bytes
        eb = element_width // 8
        elements_in_vline = self.params.vline_bytes*8//element_width
        jamlet = self.jamlets[j_in_k_index]
        vw_index = addresses.k_indices_to_vw_index(
                self.params, word_order, self.k_index, j_in_k_index)
        element_index = vline_index*elements_in_vline + index_in_j * self.params.j_in_l + vw_index
        valid_element = element_index < n_elements
        if mask_reg is not None:
            mask_bit_addr = mask_reg * wb * 8 + vline_index * (wb//eb) + index_in_j
            mask_byte = jamlet.rf_slice[mask_bit_addr//8]
            mask_bit = (mask_byte >> (mask_bit_addr % 8)) & 1
        else:
            mask_bit = 1
        return valid_element, mask_bit

    #async def _handle_load_instr_resolve(self, instr, vline_index, write_token, read_token):
    #    # This handles just one vline worth of data.
    #    # This guarantees that it will all be in the same cache line
    #    logger.info(f'kamlet ({self.min_x} {self.min_y}): _handle_load_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index} mask_reg={instr.mask_reg}')
    #    wb = self.params.word_bytes
    #    eb = instr.element_width//8
    #    m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #    k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
    #    j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
    #    assert instr.element_width % 8 == 0
    #    assert self.cache_table.can_read(k_maddr)
    #    mask_values = []
    #    valids = []
    #    old_values = []
    #    new_values = []
    #    loaded_values = []
    #    for j_in_k_index, jamlet in enumerate(self.jamlets):
    #        for index_in_j in range(wb//eb):
    #            valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
    #                                        instr.mask_reg,  vline_index, j_in_k_index, index_in_j)
    #            active = valid_element and mask_bit
    #            base_rf_addr = instr.dst*wb + vline_index*wb + index_in_j*eb
    #            base_sram_addr = j_saddr.addr + index_in_j*eb
    #            old_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
    #            if active:
    #                jamlet.rf_slice[base_rf_addr: base_rf_addr + eb] = jamlet.sram[base_sram_addr: base_sram_addr + eb]
    #            loaded_values.append(int.from_bytes(jamlet.sram[base_sram_addr: base_sram_addr + eb], byteorder='little'))
    #            new_values.append(int.from_bytes(jamlet.rf_slice[base_rf_addr: base_rf_addr + eb], byteorder='little'))
    #            mask_values.append(mask_bit)
    #            valids.append(valid_element)
    #    self.rf_info[instr.dst + vline_index].finish_write(write_token)
    #    if read_token is not None:
    #        self.rf_info[instr.mask_reg].finish_read(read_token)
    #    logger.info(f'kamlet: _handle_load_instr_resolve, base rf address={instr.dst*wb + vline_index*wb} masks are is {mask_values} valids are {valids} old_values {old_values} loaded_values = {loaded_values} new_values {new_values}')

    #async def handle_store_instr(self, instr: kinstructions.Store):
    #    logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')

    #    assert instr.element_width == instr.k_maddr.ordering.ew
    #    vline_bits = self.params.vline_bytes * 8
    #    n_vlines = (instr.n_elements * instr.element_width + vline_bits)//vline_bits

    #    read_regs = [instr.src+index for index in range(n_vlines)]
    #    if instr.mask_reg is not None:
    #        read_regs.append(instr.mask_reg)
    #    await self.wait_for_rf_available(read_regs=read_regs)

    #    # Check that the address is aligned to a vector line.
    #    assert instr.k_maddr.k_index == 0
    #    assert instr.k_maddr.addr % self.params.k_vline_bytes == 0

    #    # Make sure that we have all the cache lines that we need for writing.
    #    futures = []
    #    for vline_index in range(n_vlines):
    #        m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #        k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
    #        # We register our desire to write each vline independently since they
    #        # may be on different cache lines.
    #        read_tokens = [self.rf_info[instr.src+vline_index].start_read()]
    #        if instr.mask_reg is not None:
    #            read_tokens.append(self.rf_info[instr.mask_reg].start_read())
    #        coro = self._handle_store_instr_resolve(instr, vline_index, read_tokens)
    #        futures.append(await self.cache_table.request_write(k_maddr, coro))

    #    combined_future = self.clock.create_future()
    #    self.clock.create_task(utils.combine_futures(combined_future, futures))
    #    return combined_future

    #async def _handle_store_instr_resolve(self, instr, vline_index, read_tokens):
    #    # This handles just one vline worth of data.
    #    # This guarantees that it will all be in the same cache line
    #    logger.info(f'kamlet: _handle_store_instr_resolve {hex(instr.k_maddr.addr)} vline {vline_index}, mask_reg is {instr.mask_reg}')
    #    wb = self.params.word_bytes
    #    eb = instr.element_width//8
    #    m_addr = instr.k_maddr.addr + vline_index * self.params.k_vline_bytes
    #    k_maddr = KMAddr(k_index=self.k_index, ordering=instr.k_maddr.ordering, bit_addr=m_addr*8)
    #    j_saddr = k_maddr.to_j_saddr(self.params, self.cache_table)
    #    assert instr.element_width % 8 == 0
    #    assert self.cache_table.can_write(k_maddr)
    #    mask_values = []
    #    for index_in_j in range(wb//eb):
    #        for j_in_k_index, jamlet in enumerate(self.jamlets):
    #            valid_element, mask_bit = self.get_is_active(instr.n_elements, instr.element_width, instr.word_order,
    #                                        instr.mask_reg, vline_index, j_in_k_index, index_in_j)
    #            if valid_element and mask_bit:
    #                base_rf_addr = instr.src*wb + vline_index*wb + index_in_j*eb
    #                base_sram_addr = j_saddr.addr + index_in_j*eb
    #                jamlet.sram[base_sram_addr: base_sram_addr + eb] = jamlet.rf_slice[base_rf_addr: base_rf_addr + eb]
    #            mask_values.append(mask_bit)
    #    self.rf_info[instr.src + vline_index].finish_read(read_tokens[0])
    #    if len(read_tokens) > 1:
    #        self.rf_info[instr.mask_reg].finish_read(read_tokens[1])
    #    logger.info(f'kamlet: _handle_store_instr_resolve, masks are is {mask_values}')

    #async def handle_read_reg_element_instr(self, instr: kinstructions.ReadRegElement):
    #    """Handle reading an element from vector register."""
    #    logger.debug(f'kamlet: handle_read_reg_element_instr src=v{instr.src} element={instr.element_index}')
    #    await self.wait_for_rf_available(read_regs=[instr.src])

    #    params = self.params
    #    vreg_bytes_per_jamlet = params.maxvl_bytes // params.j_in_l
    #    eb = instr.element_width // 8

    #    # Calculate which jamlet and offset within that jamlet
    #    vw_index = instr.element_index % params.j_in_l
    #    k_index, j_in_k_index = addresses.vw_index_to_k_indices(params, addresses.WordOrder.STANDARD, vw_index)
    #    element_in_jamlet = instr.element_index // params.j_in_l

    #    if k_index == self.k_index:
    #        jamlet = self.jamlets[j_in_k_index]
    #        src_offset = instr.src * vreg_bytes_per_jamlet + element_in_jamlet * eb
    #        value_bytes = bytes(jamlet.rf_slice[src_offset:src_offset + eb])

    #        # Send response message back to lamlet
    #        header = Header(
    #            message_type=MessageType.READ_BYTES_RESP,
    #            send_type=SendType.SINGLE,
    #            value=value_bytes,
    #            target_x=jamlet.front_x,
    #            target_y=jamlet.front_y,
    #            source_x=jamlet.x,
    #            source_y=jamlet.y,
    #            address=None,
    #            length=1,
    #            ident=instr.ident,
    #        )
    #        packet = [header]
    #        send_queue = jamlet.send_queues[header.message_type]
    #        while not send_queue.can_append():
    #            await self.clock.next_cycle
    #        send_queue.append(packet)

    async def handle_item(self, witem: WaitingItem) -> None:
        if isinstance(witem, cache_table.WaitingWriteImmBytes):
            self.handle_write_imm_bytes_instr_witem(witem=witem)
        elif isinstance(witem, cache_table.WaitingReadByte):
            await self.handle_read_byte_instr_final(instr=witem.item)
        elif isinstance(witem, cache_table.WaitingLoadSimple):
            await self.handle_load_instr_simple_witem(witem=witem)
        elif isinstance(witem, cache_table.WaitingLoadWordSrc):
            await self.handle_load_word_src_witem(witem=witem)
        elif isinstance(witem, cache_table.WaitingLoadWordDst):
            await self.handle_load_word_dst_witem(witem=witem)
        elif isinstance(witem, cache_table.WaitingStoreSimple):
            await self.handle_store_instr_simple_witem(witem=witem)
        elif isinstance(witem, cache_table.WaitingLoadJ2JWords):
            await self.handle_load_instr_notsimple_witem(witem=witem)
        elif isinstance(witem, cache_table.WaitingStoreJ2JWords):
            await self.handle_store_instr_notsimple_witem(witem=witem)
        else:
            raise NotImplementedError()

    async def _monitor_items(self) -> None:
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): _monitor_items started')
        last_log_cycle = 0
        while True:
            await self.clock.next_cycle
            # Log waiting items every 100 cycles if any exist
            if self.clock.cycle - last_log_cycle >= 100:
                waiting = []
                for i, item in enumerate(self.cache_table.waiting_items):
                    if item is not None:
                        details = f"{type(item).__name__}"
                        if isinstance(item, cache_table.WaitingLoadWordSrc):
                            details += f" src={item.protocol_state} cache={item.cache_is_avail} slot={item.cache_slot}"
                        elif isinstance(item, cache_table.WaitingLoadWordDst):
                            details += f" dst={item.protocol_state} slot=None"
                        waiting.append((i, details, item.ready()))
                if waiting:
                    logger.warning(f'{self.clock.cycle}: kamlet ({self.min_x}, {self.min_y}): waiting_items: {waiting}')
                    last_log_cycle = self.clock.cycle
            for index, item in enumerate(self.cache_table.waiting_items):
                if item is None:
                    continue
                if item.ready():
                    logger.debug(f'kamlet ({self.min_x}, {self.min_y}): _monitor_items: witem {index} ready, type={type(item).__name__}')
                    self.cache_table.waiting_items[index] = None
                    await self.handle_item(item)

    async def _send_packets(self) -> None:
        while True:
            await self.clock.next_cycle
            if self._instr_send_queue:
                packet = self._instr_send_queue.popleft()
                buffer = self.jamlets[SEND_READ_LINE_J_INDEX].send_queues[packet[0].message_type]
                while not buffer.can_append():
                    await self.clock.next_cycle
                buffer.append(packet)
