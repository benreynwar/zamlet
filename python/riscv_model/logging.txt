# Logging Guide

This document lists all the logging labels used in the RISC-V VPU simulator and how to grep for them.

## Memory Allocation and Address Translation

### PAGE_ALLOC
**Location**: addresses.py - Page table allocations mapping global to physical addresses
**Format**: `PAGE_ALLOC: global=0x{start:x}-0x{end:x} -> physical=0x{phys:x} memory_loc=0x{start:x}-0x{end:x} is_vpu={bool}`
**Grep**: `grep "PAGE_ALLOC" <logfile>`
**Purpose**: Shows how global address ranges map to physical memory and memory_loc values in kamlets. The memory_loc range indicates which cache lines across all kamlets correspond to this page.
**Example**:
```
PAGE_ALLOC: global=0x20000000-0x200003ff -> physical=0x0 memory_loc=0x0-0x1f is_vpu=True
```

### CACHE_LINE_ALLOC
**Location**: cache_table.py - Cache line allocations in kamlet cache tables
**Format**: `{cycle}: CACHE_LINE_ALLOC: CacheTable ({x}, {y}) slot={slot} memory_loc=0x{loc:x}`
**Grep**: `grep "CACHE_LINE_ALLOC" <logfile>`
**Purpose**: Shows which cache slot in a specific kamlet is allocated for a given memory_loc. Combine with PAGE_ALLOC to trace from global addresses to cache slots.
**Example**:
```
7: CACHE_LINE_ALLOC: CacheTable (0, 0) slot=0 memory_loc=0x0
```

### LOAD_CACHE_CHECK
**Location**: kamlet.py - Cache hit/miss check during load operations
**Format**: `{cycle}: LOAD_CACHE_CHECK: kamlet ({x},{y}) k_maddr.addr=0x{addr:x} memory_loc=0x{loc:x} slot={slot} slot_mem_loc=0x{actual:x} can_read={bool} {HIT|MISS}`
**Grep**: `grep "LOAD_CACHE_CHECK" <logfile>`
**Purpose**: Shows whether a load found its data in cache. Displays the requested memory_loc vs what's actually in the cache slot. Critical for debugging address translation and cache correctness.
**Example**:
```
15546: LOAD_CACHE_CHECK: kamlet (0,0) k_maddr.addr=0x28 memory_loc=0x2 slot=3 slot_mem_loc=0x0 can_read=True HIT
```
Note: If memory_loc != slot_mem_loc but can_read=True, this indicates the cache lookup found the wrong data.

## Memory Operations

### MEM_WRITE
**Location**: memlet.py - Memory writes to off-chip DRAM
**Format**: `MEM_WRITE: kamlet(x,y) addr=0x{address:08x} index={index} data={hex}`
**Grep**: `grep "MEM_WRITE" <logfile>`
**Example**:
```
123: MEM_WRITE: kamlet(0,0) addr=0x00000000 index=0 data=0001010809060103
```

### MEM_READ
**Location**: memlet.py - Memory reads from off-chip DRAM
**Format**: `MEM_READ: kamlet(x,y) addr=0x{address:08x} index={index} data={hex} [(UNINITIALIZED - random)]`
**Grep**: `grep "MEM_READ" <logfile>`
**Example**:
```
456: MEM_READ: kamlet(0,0) addr=0x00000000 index=0 data=0001010809060103
```

## Cache Operations

### CACHE_WRITE READ_LINE_RESP
**Location**: jamlet.py - Cache line fills from memory
**Format**: `CACHE_WRITE READ_LINE_RESP: jamlet (x,y) sram[addr] old={hex} new={hex}`
**Grep**: `grep "CACHE_WRITE READ_LINE_RESP" <logfile>`
**Example**:
```
789: CACHE_WRITE READ_LINE_RESP: jamlet (0,0) sram[0] old=0000000000000000 new=0001010809060103
```

### CACHE_WRITE STORE_SIMPLE
**Location**: jamlet.py - Vector stores to local cache
**Format**: `CACHE_WRITE STORE_SIMPLE: jamlet (x,y) sram[addr] old={hex} new={hex} from rf[reg] mask=0x{mask:016x}`
**Grep**: `grep "CACHE_WRITE STORE_SIMPLE" <logfile>`
**Example**:
```
1003: CACHE_WRITE STORE_SIMPLE: jamlet (0,0) sram[0] old=beab05f1c379b963 new=6400000000000000 from rf[2] mask=0xffffffffffffffff
```

### CACHE_WRITE STORE_J2J
**Location**: jamlet.py - Jamlet-to-jamlet stores
**Format**: `CACHE_WRITE STORE_J2J: jamlet (x,y) sram[addr] old={hex} new={hex}`
**Grep**: `grep "CACHE_WRITE STORE_J2J" <logfile>`
**Example**:
```
1013: CACHE_WRITE STORE_J2J: jamlet (0,0) sram[8] old=728ae4360abd2222 new=0200000000000000
```

### CACHE_WRITE STORE_WORD
**Location**: jamlet.py - Single word stores
**Format**: `CACHE_WRITE STORE_WORD: jamlet (x,y) sram[addr] old={hex} new={hex}`
**Grep**: `grep "CACHE_WRITE STORE_WORD" <logfile>`

### CACHE_WRITE WRITE_IMM_BYTES
**Location**: kamlet.py - Immediate byte writes to cache (used during initialization)
**Format**: `CACHE_WRITE WRITE_IMM_BYTES: jamlet (x,y) sram[start:end] old={hex} new={hex}`
**Grep**: `grep "CACHE_WRITE WRITE_IMM_BYTES" <logfile>`
**Example**:
```
30: CACHE_WRITE WRITE_IMM_BYTES: jamlet (0,0) sram[0:1] old=6e new=00
```

## Register File Operations

### RF_WRITE LOAD_SIMPLE
**Location**: jamlet.py - Simple loads to register file
**Format**: `RF_WRITE LOAD_SIMPLE: jamlet (x,y) rf[reg] old={hex} new={hex} instr_ident={id} mask=0x{mask:016x}`
**Grep**: `grep "RF_WRITE LOAD_SIMPLE" <logfile>`
**Example**:
```
15547: RF_WRITE LOAD_SIMPLE: jamlet (0,0) rf[0] old=0000000000000000 new=0001010809060103 instr_ident=0 mask=0xffffffffffffffff
```

### RF_WRITE LOAD_J2J
**Location**: jamlet.py - Jamlet-to-jamlet loads to register file
**Format**: `RF_WRITE LOAD_J2J: jamlet (x,y) rf[reg] old={hex} new={hex}`
**Grep**: `grep "RF_WRITE LOAD_J2J" <logfile>`

### RF_WRITE VmsleViOp
**Location**: kinstructions.py - Vector mask set-less-than-or-equal-immediate writes
**Format**: `RF_WRITE VmsleViOp: jamlet (x,y) rf[reg] old={hex} new={hex}`
**Grep**: `grep "RF_WRITE VmsleViOp" <logfile>`
**Example**:
```
982: RF_WRITE VmsleViOp: jamlet (0,0) rf[0] old=08 new=08
```

### RF_WRITE VmnandMmOp
**Location**: kinstructions.py - Vector mask NAND writes
**Format**: `RF_WRITE VmnandMmOp: jamlet (x,y) rf[reg] old={hex} new={hex}`
**Grep**: `grep "RF_WRITE VmnandMmOp" <logfile>`

### RF_WRITE VBroadcastOp
**Location**: kinstructions.py - Vector broadcast writes
**Format**: `RF_WRITE VBroadcastOp: jamlet (x,y) rf[reg] old={hex} new={hex}`
**Grep**: `grep "RF_WRITE VBroadcastOp" <logfile>`

### RF_WRITE VmvVvOp
**Location**: kinstructions.py - Vector move writes
**Format**: `RF_WRITE VmvVvOp: jamlet (x,y) rf[reg] old={hex} new={hex}`
**Grep**: `grep "RF_WRITE VmvVvOp" <logfile>`

### RF_WRITE VArithVvOp
**Location**: kinstructions.py - Vector arithmetic writes
**Format**: `RF_WRITE VArithVvOp({operation}): jamlet (x,y) rf[reg] old={hex} new={hex}`
**Grep**: `grep "RF_WRITE VArithVvOp" <logfile>`

## Common Grep Patterns

### Find all writes to a specific register at a specific jamlet
```bash
grep "RF_WRITE.*jamlet (0,0).*rf\[2\]" <logfile>
```

### Find all writes to a specific cache address at a specific jamlet
```bash
grep "CACHE_WRITE.*jamlet (0,0).*sram\[0\]" <logfile>
```

### Find all memory operations for a specific kamlet
```bash
grep "MEM_.*kamlet(0,0)" <logfile>
```

### Track data flow for a global address
```bash
# Example: Tracing global address 0x20000050

# 1. Find which page and memory_loc range this address belongs to
grep "PAGE_ALLOC.*global=0x20000000" <logfile>
# Output: PAGE_ALLOC: global=0x20000000-0x200003ff -> physical=0x0 memory_loc=0x0-0x1f is_vpu=True

# 2. Find which cache slots are allocated for those memory_locs
grep "CACHE_LINE_ALLOC.*memory_loc=0x[01]" <logfile>
# Output: CACHE_LINE_ALLOC: CacheTable (0, 0) slot=0 memory_loc=0x0

# 3. Find cache writes during initialization
grep "CACHE_WRITE WRITE_IMM_BYTES.*jamlet (0,0)" <logfile>

# 4. Find cache line loads from memory
grep "CACHE_WRITE READ_LINE_RESP.*jamlet (0,0)" <logfile>

# 5. Find register file loads
grep "RF_WRITE LOAD_SIMPLE.*jamlet (0,0)" <logfile>
```

### Find all operations in a cycle range
```bash
grep "^2025.*15[45][0-9][0-9]:" <logfile>
```
