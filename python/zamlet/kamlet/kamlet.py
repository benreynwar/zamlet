import logging
from typing import List

from zamlet import addresses
from zamlet.addresses import KMAddr
from zamlet.params import LamletParams
from zamlet.jamlet.jamlet import Jamlet
from zamlet.message import Header, MessageType, SendType, AddressHeader
from zamlet.utils import Queue
from zamlet.kamlet import kinstructions, cache_table
from zamlet import memlet, register_file_slot
from zamlet.kamlet.cache_table import CacheRequestType, CacheTable, WaitingItem, SendState, ReceiveState
from zamlet.transactions import load_j2j_words, store_j2j_words
from zamlet.transactions.load_j2j_words import WaitingLoadJ2JWords
from zamlet.transactions.store_j2j_words import WaitingStoreJ2JWords
from zamlet.transactions.load_simple import WaitingLoadSimple, do_load_simple
from zamlet.transactions.store_simple import WaitingStoreSimple, do_store_simple
from zamlet.transactions import load_word, store_word
from zamlet.transactions.load_word import WaitingLoadWordSrc, WaitingLoadWordDst
from zamlet.transactions.store_word import WaitingStoreWordSrc, WaitingStoreWordDst
from zamlet.transactions.write_imm_bytes import WaitingWriteImmBytes, do_write_imm_bytes
from zamlet.transactions.read_byte import WaitingReadByte, do_read_byte


logger = logging.getLogger(__name__)





class Kamlet:
    """
    A collection of lanes.
    They share an instruction buffer, and cache tracking logic.
    """

    def __init__(self, clock, params: LamletParams, min_x: int, min_y: int, tlb: addresses.TLB):
        self.clock = clock
        self.params = params

        # A kamlet covers several (x,y) coordinate positions (one for each lane (jamlet))
        self.min_x = min_x
        self.min_y = min_y
        self.n_columns = params.j_cols
        self.n_rows = params.j_rows
        self.n_jamlets = self.n_columns * self.n_rows

        k_x = self.min_x//params.j_cols
        k_y = self.min_y//params.j_rows
        k_index = k_y * params.k_cols + k_x
        mem_coords = memlet.m_router_coords(params, k_index, 0)
        self.mem_x = mem_coords[0]
        self.mem_y = mem_coords[1]

        self.available_instruction_tokens = self.params.instruction_queue_length

        # We pass methods to the cache table to flush and read lines.
        name = f'CacheTable ({self.min_x}, {self.min_y})'
        self.cache_table = CacheTable(clock, params, name)
        rf_name = f'kamlet({self.min_x},{self.min_y})'
        self.rf_info = register_file_slot.KamletRegisterFile(self.params.n_vregs, name=rf_name)
        self.tlb = tlb

        self.jamlets = []
        for index in range(self.n_jamlets):
            x = min_x+index % self.n_columns
            y = min_y+index//self.n_columns
            self.jamlets.append(Jamlet(clock, params, x, y, self.cache_table, self.rf_info, self.tlb))

        # Local State
        self._instruction_queue = Queue(self.params.instruction_queue_length)

        # We place packets here that are generated by instructions.
        self._instr_send_queue = Queue(2)


    def rf_available(self, read_regs=None, write_regs=None):
        if read_regs is None:
            read_regs = []
        if write_regs is None:
            write_regs = []
        avail = (all(self.rf_info.can_read(r) for r in read_regs) and
                 all(self.rf_info.can_write(r) for r in write_regs))
        #for reg in read_regs:
        #    if not self.rf_info.can_read(reg):
        #        logger.debug(f'kamlet {(self.min_x, self.min_y)}: Cannot read {reg}')
        #for reg in write_regs:
        #    if not self.rf_info.can_write(reg):
        #        logger.debug(f'kamlet {(self.min_x, self.min_y)}: Cannot write {reg}')
        return avail

    async def wait_for_rf_available(self, read_regs=None, write_regs=None):
        while not self.rf_available(read_regs, write_regs):
            await self.clock.next_cycle

    def update(self):
        self._instruction_queue.update()
        self._instr_send_queue.update()
        self.cache_table.update()
        for jamlet in self.jamlets:
            jamlet.update()

    @property
    def k_index(self):
        return self.min_y // self.params.j_rows * self.params.k_cols + self.min_x // self.params.j_cols

    def get_regs(self, start_index: int, n_elements: int, base_reg: int, ew: int):
        '''
        Given a start_index and n_elements and a base register work out which vector registers
        get touched (in any kamlet, but that's good enough)
        '''
        elements_in_vline = self.params.vline_bytes * 8 // ew
        start_vline = start_index // elements_in_vline
        end_vline = (start_index + n_elements - 1) // elements_in_vline
        regs = [base_reg + vline_offset for vline_offset in range(start_vline, end_vline + 1)]
        return regs

    def get_jamlet(self, x, y):
        assert self.min_x <= x < self.min_x + self.n_columns
        assert self.min_y <= y < self.min_y + self.n_rows
        jamlet = self.jamlets[(y - self.min_y) * self.n_columns + (x - self.min_x)]
        assert jamlet.x == x
        assert jamlet.y == y
        return jamlet

    def add_to_instruction_queue(self, instr: kinstructions.KInstr):
        assert isinstance(instr, kinstructions.KInstr)
        instr_name = type(instr).__name__
        instr_ident = getattr(instr, 'instr_ident', '?')
        logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}) RECEIVE INSTRUCTION {instr_name} ident={instr_ident}')
        self._instruction_queue.append(instr)

    async def _run_instructions(self):
        while True:
            await self.clock.next_cycle
            # If we have an instruction then do it
            if self._instruction_queue:
                self.available_instruction_tokens += 1
                instruction = self._instruction_queue.popleft()
                instr_name = type(instruction).__name__
                instr_ident = getattr(instruction, 'instr_ident', '?')
                logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}) START INSTRUCTION {instr_name} ident={instr_ident}')
                await instruction.update_kamlet(self)
                logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}) END INIT INSTRUCTION {instr_name} ident={instr_ident}')

    def take_instruction_token(self):
        assert self.available_instruction_tokens > 0
        self.available_instruction_tokens -= 1

    async def _monitor_cache_requests(self):
        while True:
            await self.clock.next_cycle
            for request in self.cache_table.cache_requests:
                if request is None:
                    continue
                if not all(request.sent):
                    if request.request_type == CacheRequestType.READ_LINE:
                        await self.read_cache_line(cache_slot=request.slot, address_in_memory=request.addr, ident=request.ident)
                        self.cache_table.report_sent_request(request, 0)
                    else:
                        # Don't do anything for WRITE_LINE or WRITE_LINE_READ_LINE
                        # since those messages are sent at the jamlet level.
                        pass

    async def _get_instructions_from_jamlets(self):
        while True:
            await self.clock.next_cycle
            # Get received instructions from jamlets
            for index, jamlet in enumerate(self.jamlets):
                if jamlet._instruction_buffer:
                    if index == 0:
                        if self._instruction_queue.can_append():
                            instr = jamlet._instruction_buffer.popleft()
                            self.add_to_instruction_queue(instr)
                    else:
                        instr = jamlet._instruction_buffer.popleft()

    async def run(self):
        for jamlet in self.jamlets:
            self.clock.create_task(jamlet.run())
        self.clock.create_task(self._run_instructions())
        self.clock.create_task(self._send_packets())
        self.clock.create_task(self._get_instructions_from_jamlets())
        self.clock.create_task(self._monitor_cache_requests())
        self.clock.create_task(self._monitor_witems())
        self.clock.create_task(self.cache_table.run())

    async def read_cache_line(self, cache_slot: int, address_in_memory: int, ident: int):
        """
        Reads from memory into the cache line.
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        logger.debug('{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: read_cache_line')
        address_in_sram = cache_slot * self.params.cache_line_bytes // self.params.j_in_k

        header = AddressHeader(
            message_type=MessageType.READ_LINE, #4
            send_type=SendType.SINGLE,          #1
            target_x=self.mem_x,                #8
            target_y=self.mem_y,                #8
            source_x=self.min_x,                #8
            source_y=self.min_y,                #8
            address=address_in_sram,            #12
            length=2,                           #5
            ident=ident,               #5 bits
            )
        assert address_in_memory % self.params.cache_line_bytes == 0
        packet = [header, address_in_memory]

        while not self._instr_send_queue.can_append():
            await self.clock.next_cycle
        self._instr_send_queue.append(packet)

    async def handle_write_imm_bytes_instr(self, instr: kinstructions.WriteImmBytes):
        """
        Writes bytes to memory.
        They must all be within one word.
        It first makes sure that we've got the cache line ready.
        """
        logger.debug(f'{self.clock.cycle}: {(self.min_x, self.min_y)}: handle_write_imm_bytes_instr: {hex(instr.k_maddr.addr)}')
        if not self.cache_table.can_write(instr.k_maddr):
            witem = WaitingWriteImmBytes(instr)
            await self.cache_table.add_witem(witem, instr.k_maddr)
        else:
            do_write_imm_bytes(self, instr)

    async def handle_read_byte_instr(self, instr: kinstructions.ReadByte):
        logger.debug(f'{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: handle_read_bytes_instr')
        if not self.cache_table.can_read(instr.k_maddr):
            witem = WaitingReadByte(instr)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        else:
            await do_read_byte(self, instr)

    async def handle_load_word_instr(self, instr: kinstructions.LoadWord):
        """Handle LoadWord instruction - load partial word from cache to register."""
        is_src_kamlet = (instr.src.k_index == self.k_index)
        is_dst_kamlet = (instr.dst.k_index == self.k_index)

        logger.debug(
            f'kamlet ({self.min_x}, {self.min_y}): handle_load_word_instr '
            f'ident={instr.instr_ident} src_k={instr.src.k_index} '
            f'dst_k={instr.dst.k_index} is_src={is_src_kamlet} is_dst={is_dst_kamlet}')

        if not (is_src_kamlet or is_dst_kamlet):
            return

        if is_src_kamlet:
            witem_src = WaitingLoadWordSrc(params=self.params, instr=instr)
            await self.cache_table.add_witem(witem=witem_src, k_maddr=instr.src)
            for jamlet in self.jamlets:
                load_word.init_src_state(jamlet, witem_src)

        if is_dst_kamlet:
            read_regs = [instr.mask_reg] if instr.mask_reg is not None else []
            await self.wait_for_rf_available(write_regs=[instr.dst.reg], read_regs=read_regs)
            rf_write_ident = self.rf_info.start(read_regs=read_regs, write_regs=[instr.dst.reg])
            witem_dst = WaitingLoadWordDst(params=self.params, instr=instr, rf_ident=rf_write_ident)
            await self.cache_table.add_witem(witem=witem_dst)
            for jamlet in self.jamlets:
                load_word.init_dst_state(jamlet, witem_dst)

    async def handle_store_word_instr(self, instr: kinstructions.StoreWord):
        """Handle StoreWord instruction - store partial word from register to cache."""
        is_src_kamlet = (instr.src.k_index == self.k_index)
        is_dst_kamlet = (instr.dst.k_index == self.k_index)

        logger.debug(
            f'kamlet ({self.min_x}, {self.min_y}): handle_store_word_instr '
            f'ident={instr.instr_ident} src_k={instr.src.k_index} '
            f'dst_k={instr.dst.k_index} is_src={is_src_kamlet} is_dst={is_dst_kamlet}')

        if is_src_kamlet:
            read_regs = [instr.src.reg] + ([instr.mask_reg] if instr.mask_reg is not None else [])
            await self.wait_for_rf_available(read_regs=read_regs)
            rf_read_ident = self.rf_info.start(read_regs=read_regs)
            witem_src = WaitingStoreWordSrc(params=self.params, instr=instr, rf_ident=rf_read_ident)
            await self.cache_table.add_witem(witem=witem_src)
            for jamlet in self.jamlets:
                store_word.init_src_state(jamlet, witem_src)

        if is_dst_kamlet:
            witem_dst = WaitingStoreWordDst(params=self.params, instr=instr)
            await self.cache_table.add_witem(witem=witem_dst, k_maddr=instr.dst)
            for jamlet in self.jamlets:
                store_word.init_dst_state(jamlet, witem_dst)

    #
    #  Dealing with Load instruction
    #

    async def handle_load_instr(self, instr: kinstructions.Load):
        """
        When we receive a load:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        ew_match = instr.dst_ordering.ew == instr.k_maddr.ordering.ew
        physical_vline_addr = instr.k_maddr.to_physical_vline_addr()
        aligned = (physical_vline_addr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_instr addr={hex(instr.k_maddr.addr)} ew_match={ew_match} aligned={aligned} dst_ew={instr.dst_ordering.ew} mem_ew={instr.k_maddr.ordering.ew}')
        if ew_match and aligned:
            await self.handle_load_instr_simple(instr)
        else:
            await self.handle_load_instr_notsimple(instr)

    async def handle_load_instr_simple(self, instr: kinstructions.Load) -> None:
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        read_regs = [instr.mask_reg] if instr.mask_reg is not None else []
        logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): handle_load_instr_simple '
                       f'instr_ident={instr.instr_ident} WAITING for dst_regs={dst_regs} read_regs={read_regs}')
        await self.wait_for_rf_available(write_regs=dst_regs, read_regs=read_regs)
        rf_ident = self.rf_info.start(read_regs=read_regs, write_regs=dst_regs)
        logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): handle_load_instr_simple '
                       f'instr_ident={instr.instr_ident} GOT rf_ident={rf_ident}')

        slot = self.cache_table.addr_to_slot(instr.k_maddr)
        memory_loc = instr.k_maddr.addr // self.cache_table.cache_line_bytes
        can_read = self.cache_table.can_read(instr.k_maddr)

        if slot is not None:
            actual_mem_loc = self.cache_table.slot_states[slot].memory_loc
            logger.debug(
                f'{self.clock.cycle}: LOAD_CACHE_CHECK: kamlet ({self.min_x},{self.min_y}) '
                f'k_maddr.addr=0x{instr.k_maddr.addr:x} memory_loc=0x{memory_loc:x} '
                f'slot={slot} slot_mem_loc=0x{actual_mem_loc:x} can_read={can_read} '
                f'{"HIT" if can_read else "MISS"}'
            )
        else:
            logger.debug(
                f'{self.clock.cycle}: LOAD_CACHE_CHECK: kamlet ({self.min_x},{self.min_y}) '
                f'k_maddr.addr=0x{instr.k_maddr.addr:x} memory_loc=0x{memory_loc:x} '
                f'slot=None can_read={can_read} MISS'
            )

        if can_read:
            logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): handle_load_instr_simple can read')
            assert self.cache_table.can_read(instr.k_maddr)
            logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): LOAD_SIMPLE '
                           f'instr_ident={instr.instr_ident} dst=v{instr.dst} '
                           f'mask_reg={instr.mask_reg} rf_ident={rf_ident}')
            for jamlet in self.jamlets:
                do_load_simple(jamlet, instr)
            logger.debug(f'>>>>>>>>>>> {self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): LOAD_SIMPLE FINISH '
                           f'instr_ident={instr.instr_ident} dst_regs={dst_regs} read_regs={read_regs}')
            self.rf_info.finish(rf_ident, write_regs=dst_regs, read_regs=read_regs)
        else:
            logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): handle_load_instr_simple get cache')
            witem = WaitingLoadSimple(instr=instr, rf_ident=rf_ident)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    async def handle_load_instr_notsimple(self, instr: kinstructions.Load) -> None:
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_instr_notsimple addr={hex(instr.k_maddr.addr)} ident={instr.instr_ident}')
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        if instr.mask_reg is not None:
            read_regs = [instr.mask_reg]
        else:
            read_regs = []
        await self.wait_for_rf_available(write_regs=dst_regs, read_regs=read_regs)
        rf_write_ident = self.rf_info.start(read_regs=read_regs, write_regs=dst_regs)
        witem = WaitingLoadJ2JWords(
                params=self.params, instr=instr, rf_ident=rf_write_ident)
        await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        instr = witem.item
        for jamlet in self.jamlets:
            for tag in range(self.params.word_bytes):
                load_j2j_words.init_dst_state(jamlet, witem, tag)
                load_j2j_words.init_src_state(jamlet, witem, tag)

    #
    #  Dealing with Store instruction
    #

    async def handle_store_instr(self, instr: kinstructions.Store):
        """
        When we receive a store:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')
        ew_match = instr.src_ordering.ew == instr.k_maddr.ordering.ew
        physical_vline_addr = instr.k_maddr.to_physical_vline_addr()
        aligned = (physical_vline_addr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        if ew_match and aligned:
            await self.handle_store_instr_simple(instr)
        else:
            await self.handle_store_instr_notsimple(instr)

    async def handle_store_instr_simple(self, instr: kinstructions.Store) -> None:
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        read_regs = src_regs + ([instr.mask_reg] if instr.mask_reg is not None else [])
        await self.wait_for_rf_available(read_regs=read_regs)
        rf_read_ident = self.rf_info.start(read_regs=read_regs)
        if self.cache_table.can_read(instr.k_maddr):
            assert self.cache_table.can_write(instr.k_maddr)
            for jamlet in self.jamlets:
                do_store_simple(jamlet, instr)
            cache_state = self.cache_table.get_state(instr.k_maddr)
            cache_state.state = cache_table.CacheState.MODIFIED
            self.rf_info.finish(rf_read_ident, read_regs=read_regs)
        else:
            witem = WaitingStoreSimple(instr=instr, rf_ident=rf_read_ident)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    async def handle_store_instr_notsimple(self, instr: kinstructions.Store) -> None:
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_store_instr_notsimple addr={hex(instr.k_maddr.addr)} ident={instr.instr_ident}')
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        if instr.mask_reg is not None:
            read_regs = src_regs + [instr.mask_reg]
        else:
            read_regs = src_regs
        await self.wait_for_rf_available(read_regs=read_regs)
        rf_read_ident = self.rf_info.start(read_regs=read_regs)
        witem = WaitingStoreJ2JWords(
                params=self.params, instr=instr, rf_ident=rf_read_ident)
        logger.debug(f'***** cycle {self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: handle_store_instr_notsimple - Create witem ident={instr.instr_ident}')
        await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        for jamlet in self.jamlets:
            for tag in range(self.params.word_bytes):
                store_j2j_words.init_dst_state(jamlet, witem, tag)
                store_j2j_words.init_src_state(jamlet, witem, tag)

    #async def handle_load_stride_instr(self, instr: kinstructions.Load) -> None:
    #    logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_stride_instr addr={hex(instr.k_maddr.addr)} ident={instr.instr_ident}')
    #    dst_regs = self.get_regs(
    #            start_index=instr.start_index, n_elements=instr.n_elements,
    #            ew=instr.dst_ordering.ew, base_reg=instr.dst)
    #    if instr.mask_reg is not None:
    #        read_regs = [instr.mask_reg]
    #    else:
    #        read_regs = []
    #    await self.wait_for_rf_available(write_regs=dst_regs, read_regs=read_regs)
    #    rf_write_ident = self.rf_info.start(read_regs=read_regs, write_regs=dst_regs)
    #    witem = cache_table.WaitingLoadStride(
    #            params=self.params, instr=instr, rf_ident=rf_write_ident)
    #    await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    #async def handle_load_stride_instr_send_finished(self, witem: cache_table.WaitingLoadStride):
    #    '''
    #    This is called when the jamlets for this kamlet have sent all their messages.
    #    It releases the registers and kicks off a lamlet wide synchonrization.
    #    '''
    #    instr = witem.item
    #    for pstate in witem.protocol_states:
    #        assert pstate == SendState.COMPLETE
    #    assert witem.rf_ident is not None
    #    dst_regs = self.get_regs(
    #            start_index=instr.start_index, n_elements=instr.n_elements,
    #            ew=instr.dst_ordering.ew, base_reg=instr.dst)
    #    if instr.mask_reg is not None:
    #        read_regs = [instr.mask_reg]
    #    else:
    #        read_regs = []
    #    logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_stride_instr_write releasing regs {read_regs}')
    #    self.rf_info.finish(witem.rf_ident, read_regs=read_regs, write_regs=dst_regs)
    #    self.sync.finish(witem)

    #async def handle_load_stride_instr_receive_finished(self, witem: cache_table.WaitingLoadStride):
    #    '''
    #    This is called when all jamlets in all kamlets have sent and received responses for all their
    #    messages. After this we can delete the witem.
    #    '''
    #    pass

    def get_is_active(self, start_index, n_elements, element_width, word_order, mask_reg, vline_index, j_in_k_index, index_in_j):
        '''
        Consider an element specified by:
          what vline_index in the vector it is
          what j_in_k_index it is in (what jamlet in the kamlet)
          what element it is in that work (index_in_j)
          what reg we're using for the masks
          we know what k_index is because we know what kamlet we are
        '''
        ww = self.params.word_bytes * 8
        ew = element_width
        elements_in_vline = self.params.vline_bytes*8//ew
        jamlet = self.jamlets[j_in_k_index]
        vw_index = addresses.k_indices_to_vw_index(
                self.params, word_order, self.k_index, j_in_k_index)
        element_index = vline_index*elements_in_vline + index_in_j * self.params.j_in_l + vw_index
        valid_element = start_index <= element_index < n_elements
        if mask_reg is not None:
            mask_bit_addr = mask_reg * ww + element_index//self.params.j_in_l
            mask_byte = jamlet.rf_slice[mask_bit_addr//8]
            mask_bit = (mask_byte >> (mask_bit_addr % 8)) & 1
        else:
            mask_bit = 1
        return valid_element, mask_bit

    async def handle_item(self, witem: WaitingItem) -> None:
        await witem.finalize(self)

    async def _monitor_witems(self) -> None:
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): _monitor_witems started')
        last_log_cycle = 0
        while True:
            await self.clock.next_cycle
            for index, item in enumerate(self.cache_table.waiting_items):
                if item is None:
                    continue
                if item.ready():
                    self.cache_table.waiting_items[index] = None
                    await self.handle_item(item)

    async def _send_packets(self) -> None:
        while True:
            await self.clock.next_cycle
            if self._instr_send_queue:
                packet = self._instr_send_queue.popleft()
                send_index = self.params.send_read_line_j_index
                buffer = self.jamlets[send_index].send_queues[packet[0].message_type]
                while not buffer.can_append():
                    await self.clock.next_cycle
                buffer.append(packet)
