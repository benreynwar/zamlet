import logging
from typing import List

from zamlet import addresses
from zamlet.addresses import KMAddr
from zamlet.params import LamletParams
from zamlet.jamlet.jamlet import Jamlet
from zamlet.message import Header, MessageType, SendType, AddressHeader
from zamlet.utils import Queue
from zamlet.kamlet import kinstructions, cache_table
from zamlet.synchronization import Synchronizer
from zamlet import memlet, register_file_slot
from zamlet.kamlet.cache_table import CacheRequestType, CacheTable, WaitingItem, SendState, ReceiveState
from zamlet.transactions import load_j2j_words, store_j2j_words
from zamlet.transactions.load_j2j_words import WaitingLoadJ2JWords
from zamlet.transactions.store_j2j_words import WaitingStoreJ2JWords
from zamlet.transactions.load_simple import WaitingLoadSimple, do_load_simple
from zamlet.transactions.store_simple import WaitingStoreSimple, do_store_simple
from zamlet.transactions import load_word, store_word
from zamlet.transactions.load_word import WaitingLoadWordSrc, WaitingLoadWordDst
from zamlet.transactions.store_word import WaitingStoreWordSrc, WaitingStoreWordDst
from zamlet.transactions.write_imm_bytes import WaitingWriteImmBytes
from zamlet.transactions.read_byte import WaitingReadByte
from zamlet.monitor import Monitor, WitemSnapshot, KamletSnapshot


logger = logging.getLogger(__name__)





class Kamlet:
    """
    A collection of lanes.
    They share an instruction buffer, and cache tracking logic.
    """

    def __init__(self, clock, params: LamletParams, min_x: int, min_y: int, tlb: addresses.TLB,
                 monitor: Monitor, lamlet_x: int, lamlet_y: int):
        self.clock = clock
        self.params = params
        self.monitor = monitor
        self.lamlet_x = lamlet_x
        self.lamlet_y = lamlet_y

        # A kamlet covers several (x,y) coordinate positions (one for each lane (jamlet))
        self.min_x = min_x
        self.min_y = min_y
        self.n_columns = params.j_cols
        self.n_rows = params.j_rows
        self.n_jamlets = self.n_columns * self.n_rows

        k_x = self.min_x//params.j_cols
        k_y = self.min_y//params.j_rows
        k_index = k_y * params.k_cols + k_x
        mem_coords = memlet.m_router_coords(params, k_index, 0)
        self.mem_x = mem_coords[0]
        self.mem_y = mem_coords[1]

        # We pass methods to the cache table to flush and read lines.
        name = f'CacheTable ({self.min_x}, {self.min_y})'
        self.cache_table = CacheTable(clock, params, name, monitor,
                                      kamlet_x=self.min_x, kamlet_y=self.min_y)
        rf_name = f'kamlet({self.min_x},{self.min_y})'
        self.rf_info = register_file_slot.KamletRegisterFile(self.params.n_vregs, name=rf_name)
        self.tlb = tlb

        # One synchronizer per kamlet for tracking when operations complete across kamlets
        self.synchronizer = Synchronizer(clock, params, k_x, k_y, self.cache_table, monitor)

        self.jamlets = []
        for index in range(self.n_jamlets):
            x = min_x+index % self.n_columns
            y = min_y+index//self.n_columns
            self.jamlets.append(Jamlet(clock, params, x, y, self.cache_table, self.rf_info,
                                       self.tlb, monitor, lamlet_x, lamlet_y))

        # Local State
        # 0 = no bound (full 64-bit indices), N = mask indices to lower N bits
        self.index_bound_bits: int = 0

        self._instruction_queue = Queue(self.params.instruction_queue_length)

        # We place packets here that are generated by instructions.
        self._instr_send_queue = Queue(2)


    def rf_available(self, read_regs=None, write_regs=None):
        if read_regs is None:
            read_regs = []
        if write_regs is None:
            write_regs = []
        avail = (all(self.rf_info.can_read(r) for r in read_regs) and
                 all(self.rf_info.can_write(r) for r in write_regs))
        #for reg in read_regs:
        #    if not self.rf_info.can_read(reg):
        #        logger.debug(f'kamlet {(self.min_x, self.min_y)}: Cannot read {reg}')
        #for reg in write_regs:
        #    if not self.rf_info.can_write(reg):
        #        logger.debug(f'kamlet {(self.min_x, self.min_y)}: Cannot write {reg}')
        return avail

    async def wait_for_rf_available(self, read_regs=None, write_regs=None, instr_ident: int | None = None):
        if self.rf_available(read_regs, write_regs):
            return
        if instr_ident is not None:
            self.monitor.record_rf_blocking(
                instr_ident, self.min_x, self.min_y,
                read_regs, write_regs, self.rf_info, self.cache_table.waiting_items)
        while not self.rf_available(read_regs, write_regs):
            await self.clock.next_cycle

    def update(self):
        self._instruction_queue.update()
        self._instr_send_queue.update()
        self.cache_table.update()
        self.synchronizer.update()
        for jamlet in self.jamlets:
            jamlet.update()

    @property
    def k_index(self):
        return self.min_y // self.params.j_rows * self.params.k_cols + self.min_x // self.params.j_cols

    def get_regs(self, start_index: int, n_elements: int, base_reg: int, ew: int):
        '''
        Given a start_index and n_elements and a base register work out which vector registers
        get touched (in any kamlet, but that's good enough)
        '''
        elements_in_vline = self.params.vline_bytes * 8 // ew
        start_vline = start_index // elements_in_vline
        end_vline = (start_index + n_elements - 1) // elements_in_vline
        regs = [base_reg + vline_offset for vline_offset in range(start_vline, end_vline + 1)]
        return regs

    def get_jamlet(self, x, y):
        assert self.min_x <= x < self.min_x + self.n_columns
        assert self.min_y <= y < self.min_y + self.n_rows
        jamlet = self.jamlets[(y - self.min_y) * self.n_columns + (x - self.min_x)]
        assert jamlet.x == x
        assert jamlet.y == y
        return jamlet

    def add_to_instruction_queue(self, instr: kinstructions.KInstr):
        assert isinstance(instr, kinstructions.KInstr)
        instr_name = type(instr).__name__
        instr_ident = getattr(instr, 'instr_ident', '?')
        logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}) RECEIVE INSTRUCTION {instr_name} ident={instr_ident}')
        self._instruction_queue.append(instr)
        self.monitor.record_kamlet_instr_added(self.min_x, self.min_y)

    def _snapshot_witems(self) -> list[WitemSnapshot]:
        """Snapshot current WITEM state for visualization."""
        snapshots = []
        for witem in self.cache_table.waiting_items:
            name = type(witem).__name__
            ident = witem.instr_ident
            states = getattr(witem, 'transaction_states', None)
            if states is not None:
                tag_states = []
                for s in states:
                    if s in (SendState.INITIAL, SendState.NEED_TO_SEND,
                             SendState.WAITING_IN_CASE_FAULT):
                        tag_states.append(1)  # unsent (red)
                    elif s == SendState.WAITING_FOR_RESPONSE:
                        tag_states.append(2)  # pending (blue)
                    elif s == SendState.COMPLETE:
                        tag_states.append(3)  # complete (green)
                    else:
                        tag_states.append(0)
            else:
                tag_states = [3 if witem.ready() else 1]
            snapshots.append(WitemSnapshot(
                name=name, instr_ident=ident, tag_states=tag_states))
        return snapshots

    async def _monitor_instruction_queue(self):
        while True:
            await self.clock.next_cycle
            self.monitor.record_kamlet_cycle_state(
                self.min_x, self.min_y, len(self._instruction_queue),
            )
            # Snapshot instruction queue + WITEM state
            next_instrs = []
            for instr in list(self._instruction_queue.queue)[:2]:
                iname = type(instr).__name__
                iident = getattr(instr, 'instr_ident', -1)
                next_instrs.append((iname, iident))
            snapshot = KamletSnapshot(
                next_instructions=next_instrs,
                witems=self._snapshot_witems(),
            )
            self.monitor.record_kamlet_snapshot(
                self.min_x, self.min_y, snapshot)

    async def _run_instructions(self):
        while True:
            await self.clock.next_cycle
            # If we have an instruction then do it
            if self._instruction_queue:
                instruction = self._instruction_queue.popleft()
                self.monitor.record_kamlet_instr_removed(self.min_x, self.min_y)
                instr_name = type(instruction).__name__
                instr_ident = getattr(instruction, 'instr_ident', '?')
                logger.info(
                    f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y})'
                    f' instr_queue: {len(self._instruction_queue)}'
                    f' START {instr_name} ident={instr_ident}')
                logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}) START INSTRUCTION {instr_name} ident={instr_ident}')
                await instruction.update_kamlet(self)
                logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}) END INIT INSTRUCTION {instr_name} ident={instr_ident}')

    async def _monitor_cache_requests(self):
        while True:
            await self.clock.next_cycle
            for request in self.cache_table.cache_requests:
                if request is None:
                    continue
                if not all(request.sent):
                    if request.request_type == CacheRequestType.READ_LINE:
                        await self.read_cache_line(cache_slot=request.slot, address_in_memory=request.addr, ident=request.ident)
                        self.cache_table.report_sent_request(request, 0)
                    elif request.request_type == CacheRequestType.WRITE_LINE_READ_LINE:
                        slot_state = self.cache_table.slot_states[request.slot]
                        write_address = request.addr
                        read_address = slot_state.memory_loc * self.params.cache_line_bytes
                        tasks = []
                        for j_in_k_index, jamlet in enumerate(self.jamlets):
                            task = jamlet.write_read_cache_line(
                                cache_slot=request.slot,
                                write_address=write_address,
                                read_address=read_address,
                                ident=request.ident)
                            tasks.append(task)
                        for task in tasks:
                            await task
                        for j_in_k_index in range(len(self.jamlets)):
                            self.cache_table.report_sent_request(request, j_in_k_index)

    async def _get_instructions_from_jamlets(self):
        while True:
            await self.clock.next_cycle
            # Get received instructions from jamlets
            for index, jamlet in enumerate(self.jamlets):
                if jamlet._instruction_buffer:
                    if index == 0:
                        if self._instruction_queue.can_append():
                            instr = jamlet._instruction_buffer.popleft()
                            self.add_to_instruction_queue(instr)
                    else:
                        instr = jamlet._instruction_buffer.popleft()

    async def run(self):
        for jamlet in self.jamlets:
            self.clock.create_task(jamlet.run())
        self.clock.create_task(self._run_instructions())
        self.clock.create_task(self._monitor_instruction_queue())
        self.clock.create_task(self._send_packets())
        self.clock.create_task(self._get_instructions_from_jamlets())
        self.clock.create_task(self._monitor_cache_requests())
        self.clock.create_task(self._monitor_witems())
        self.clock.create_task(self.cache_table.run())
        self.clock.create_task(self.synchronizer.run())

    async def _queue_cache_request(self, packet, slot: int):
        """Queue a cache request packet and record the message sent."""
        header = packet[0]
        while not self._instr_send_queue.can_append():
            await self.clock.next_cycle
        self._instr_send_queue.append(packet)

        cache_request_span_id = self.monitor.get_cache_request_span_id(
            self.min_x, self.min_y, slot)
        self.monitor.record_message_sent(
            cache_request_span_id, header.message_type.name,
            ident=header.ident, tag=slot,
            src_x=header.source_x, src_y=header.source_y,
            dst_x=header.target_x, dst_y=header.target_y)

    async def read_cache_line(self, cache_slot: int, address_in_memory: int, ident: int):
        """
        Reads from memory into the cache line.
        This function should only be called by our CacheTable.
        We pass it to the cache table's constructor.
        """
        logger.debug('{self.clock.cycle}: kamlet {(self.min_x, self.min_y)}: read_cache_line')
        address_in_sram = cache_slot * self.params.cache_line_bytes // self.params.j_in_k
        send_jamlet = self.jamlets[self.params.send_read_line_j_index]

        header = AddressHeader(
            message_type=MessageType.READ_LINE, #4
            send_type=SendType.SINGLE,          #1
            target_x=self.mem_x,                #8
            target_y=self.mem_y,                #8
            source_x=send_jamlet.x,             #8
            source_y=send_jamlet.y,             #8
            address=address_in_sram,            #12
            length=2,                           #5
            ident=ident,               #5 bits
            )
        assert address_in_memory % self.params.cache_line_bytes == 0
        packet = [header, address_in_memory]

        await self._queue_cache_request(packet, cache_slot)

    async def handle_load_word_instr(self, instr: kinstructions.LoadWord):
        """Handle LoadWord instruction - load partial word from cache to register."""
        is_src_kamlet = (instr.src.k_index == self.k_index)
        is_dst_kamlet = (instr.dst.k_index == self.k_index)

        if not (is_src_kamlet or is_dst_kamlet):
            self.monitor.finalize_kinstr_exec(instr.instr_ident, self.min_x, self.min_y)
            return

        if is_src_kamlet:
            witem_src = WaitingLoadWordSrc(params=self.params, instr=instr)
            self.monitor.record_witem_created(
                instr.instr_ident, self.min_x, self.min_y, 'WaitingLoadWordSrc',
                finalize=not is_dst_kamlet)
            await self.cache_table.add_witem(witem=witem_src, k_maddr=instr.src)
            for jamlet in self.jamlets:
                load_word.init_src_state(jamlet, witem_src)

        if is_dst_kamlet:
            read_regs = [instr.mask_reg] if instr.mask_reg is not None else []
            write_regs = [instr.dst.reg]
            await self.wait_for_rf_available(write_regs=write_regs, read_regs=read_regs,
                                             instr_ident=instr.instr_ident)
            rf_write_ident = self.rf_info.start(read_regs=read_regs, write_regs=write_regs)
            witem_dst = WaitingLoadWordDst(params=self.params, instr=instr, rf_ident=rf_write_ident)
            parent_span = self.monitor.get_kinstr_exec_span_id(
                instr.instr_ident, self.min_x, self.min_y)
            self.monitor.record_witem_created(
                instr.instr_ident + 1, self.min_x, self.min_y, 'WaitingLoadWordDst',
                parent_span_id=parent_span, read_regs=read_regs, write_regs=write_regs)
            await self.cache_table.add_witem(witem=witem_dst)
            for jamlet in self.jamlets:
                load_word.init_dst_state(jamlet, witem_dst)

    async def handle_store_word_instr(self, instr: kinstructions.StoreWord):
        """Handle StoreWord instruction - store partial word from register to cache."""
        is_src_kamlet = (instr.src.k_index == self.k_index)
        is_dst_kamlet = (instr.dst.k_index == self.k_index)

        if not (is_src_kamlet or is_dst_kamlet):
            self.monitor.finalize_kinstr_exec(instr.instr_ident, self.min_x, self.min_y)
            return

        if is_src_kamlet:
            read_regs = [instr.src.reg] + ([instr.mask_reg] if instr.mask_reg is not None else [])
            await self.wait_for_rf_available(read_regs=read_regs, instr_ident=instr.instr_ident)
            rf_read_ident = self.rf_info.start(read_regs=read_regs)
            witem_src = WaitingStoreWordSrc(params=self.params, instr=instr, rf_ident=rf_read_ident)
            self.monitor.record_witem_created(
                instr.instr_ident, self.min_x, self.min_y, 'WaitingStoreWordSrc',
                finalize=not is_dst_kamlet, read_regs=read_regs)
            await self.cache_table.add_witem(witem=witem_src)
            for jamlet in self.jamlets:
                store_word.init_src_state(jamlet, witem_src)

        if is_dst_kamlet:
            witem_dst = WaitingStoreWordDst(params=self.params, instr=instr)
            parent_span = self.monitor.get_kinstr_exec_span_id(
                instr.instr_ident, self.min_x, self.min_y)
            self.monitor.record_witem_created(
                instr.instr_ident + 1, self.min_x, self.min_y, 'WaitingStoreWordDst',
                parent_span_id=parent_span)
            await self.cache_table.add_witem(witem=witem_dst, k_maddr=instr.dst)
            for jamlet in self.jamlets:
                store_word.init_dst_state(jamlet, witem_dst)

    #
    #  Dealing with Load instruction
    #

    async def handle_load_instr(self, instr: kinstructions.Load):
        """
        When we receive a load:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        ew_match = instr.dst_ordering.ew == instr.k_maddr.ordering.ew
        physical_vline_addr = instr.k_maddr.to_physical_vline_addr()
        aligned = (physical_vline_addr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_instr addr={hex(instr.k_maddr.addr)} ew_match={ew_match} aligned={aligned} dst_ew={instr.dst_ordering.ew} mem_ew={instr.k_maddr.ordering.ew}')
        if ew_match and aligned:
            await self.handle_load_instr_simple(instr)
        else:
            await self.handle_load_instr_notsimple(instr)

    async def handle_load_instr_simple(self, instr: kinstructions.Load) -> None:
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        read_regs = [instr.mask_reg] if instr.mask_reg is not None else []
        logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): handle_load_instr_simple '
                       f'instr_ident={instr.instr_ident} WAITING for dst_regs={dst_regs} read_regs={read_regs}')
        await self.wait_for_rf_available(write_regs=dst_regs, read_regs=read_regs,
                                         instr_ident=instr.instr_ident)
        rf_ident = self.rf_info.start(read_regs=read_regs, write_regs=dst_regs)
        logger.debug(f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}): handle_load_instr_simple '
                       f'instr_ident={instr.instr_ident} GOT rf_ident={rf_ident}')

        slot = self.cache_table.addr_to_slot(instr.k_maddr)
        memory_loc = instr.k_maddr.addr // self.cache_table.cache_line_bytes
        ws = instr.writeset_ident
        can_read = self.cache_table.can_read(instr.k_maddr, writeset_ident=ws)

        if slot is not None:
            actual_mem_loc = self.cache_table.slot_states[slot].memory_loc
            logger.debug(
                f'{self.clock.cycle}: LOAD_CACHE_CHECK: kamlet ({self.min_x},{self.min_y}) '
                f'k_maddr.addr=0x{instr.k_maddr.addr:x} memory_loc=0x{memory_loc:x} '
                f'slot={slot} slot_mem_loc=0x{actual_mem_loc:x} can_read={can_read} '
                f'{"HIT" if can_read else "MISS"}'
            )
        else:
            logger.debug(
                f'{self.clock.cycle}: LOAD_CACHE_CHECK: kamlet ({self.min_x},{self.min_y}) '
                f'k_maddr.addr=0x{instr.k_maddr.addr:x} memory_loc=0x{memory_loc:x} '
                f'slot=None can_read={can_read} MISS'
            )

        if can_read:
            assert self.cache_table.can_read(instr.k_maddr, writeset_ident=ws)
            for jamlet in self.jamlets:
                do_load_simple(jamlet, instr)
            self.rf_info.finish(rf_ident, write_regs=dst_regs, read_regs=read_regs)
            self.monitor.finalize_kinstr_exec(instr.instr_ident, self.min_x, self.min_y)
        else:
            witem = WaitingLoadSimple(instr=instr, rf_ident=rf_ident)
            self.monitor.record_witem_created(
                instr.instr_ident, self.min_x, self.min_y, 'WaitingLoadSimple',
                read_regs=read_regs, write_regs=dst_regs)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    async def handle_load_instr_notsimple(self, instr: kinstructions.Load) -> None:
        dst_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.dst_ordering.ew, base_reg=instr.dst)
        if instr.mask_reg is not None:
            read_regs = [instr.mask_reg]
        else:
            read_regs = []
        await self.wait_for_rf_available(write_regs=dst_regs, read_regs=read_regs,
                                         instr_ident=instr.instr_ident)
        rf_write_ident = self.rf_info.start(read_regs=read_regs, write_regs=dst_regs)
        witem = WaitingLoadJ2JWords(
                params=self.params, instr=instr, rf_ident=rf_write_ident)
        self.monitor.record_witem_created(
            instr.instr_ident, self.min_x, self.min_y, 'WaitingLoadJ2JWords',
            read_regs=read_regs, write_regs=dst_regs)
        await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        instr = witem.item
        for jamlet in self.jamlets:
            for tag in range(self.params.word_bytes):
                load_j2j_words.init_dst_state(jamlet, witem, tag)
                load_j2j_words.init_src_state(jamlet, witem, tag)

    #
    #  Dealing with Store instruction
    #

    async def handle_store_instr(self, instr: kinstructions.Store):
        """
        When we receive a store:
          if the ew match and the address is aligned to the vline
          then we do a local load.
        Otherwise we work out who we need to send packets to.
        """
        logger.debug(f'kamlet: handle_store_instr {hex(instr.k_maddr.addr)}')
        ew_match = instr.src_ordering.ew == instr.k_maddr.ordering.ew
        physical_vline_addr = instr.k_maddr.to_physical_vline_addr()
        aligned = (physical_vline_addr.bit_addr - instr.start_index * instr.k_maddr.ordering.ew) % (self.params.vline_bytes*8) == 0
        if ew_match and aligned:
            await self.handle_store_instr_simple(instr)
        else:
            await self.handle_store_instr_notsimple(instr)

    async def handle_store_instr_simple(self, instr: kinstructions.Store) -> None:
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        read_regs = src_regs + ([instr.mask_reg] if instr.mask_reg is not None else [])
        await self.wait_for_rf_available(read_regs=read_regs, instr_ident=instr.instr_ident)
        rf_read_ident = self.rf_info.start(read_regs=read_regs)
        if self.cache_table.can_write(instr.k_maddr, writeset_ident=instr.writeset_ident):
            for jamlet in self.jamlets:
                do_store_simple(jamlet, instr)
            cache_state = self.cache_table.get_state(instr.k_maddr)
            cache_state.state = cache_table.CacheState.MODIFIED
            self.rf_info.finish(rf_read_ident, read_regs=read_regs)
            self.monitor.finalize_kinstr_exec(instr.instr_ident, self.min_x, self.min_y)
        else:
            witem = WaitingStoreSimple(instr=instr, rf_ident=rf_read_ident)
            self.monitor.record_witem_created(
                instr.instr_ident, self.min_x, self.min_y, 'WaitingStoreSimple',
                read_regs=read_regs)
            await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    async def handle_store_instr_notsimple(self, instr: kinstructions.Store) -> None:
        src_regs = self.get_regs(
                start_index=instr.start_index, n_elements=instr.n_elements,
                ew=instr.src_ordering.ew, base_reg=instr.src)
        if instr.mask_reg is not None:
            read_regs = src_regs + [instr.mask_reg]
        else:
            read_regs = src_regs
        await self.wait_for_rf_available(read_regs=read_regs, instr_ident=instr.instr_ident)
        rf_read_ident = self.rf_info.start(read_regs=read_regs)
        witem = WaitingStoreJ2JWords(
                params=self.params, instr=instr, rf_ident=rf_read_ident)
        self.monitor.record_witem_created(
            instr.instr_ident, self.min_x, self.min_y, 'WaitingStoreJ2JWords',
            read_regs=read_regs)
        await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)
        for jamlet in self.jamlets:
            for tag in range(self.params.word_bytes):
                store_j2j_words.init_dst_state(jamlet, witem, tag)
                store_j2j_words.init_src_state(jamlet, witem, tag)

    #async def handle_load_stride_instr(self, instr: kinstructions.Load) -> None:
    #    logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_stride_instr addr={hex(instr.k_maddr.addr)} ident={instr.instr_ident}')
    #    dst_regs = self.get_regs(
    #            start_index=instr.start_index, n_elements=instr.n_elements,
    #            ew=instr.dst_ordering.ew, base_reg=instr.dst)
    #    if instr.mask_reg is not None:
    #        read_regs = [instr.mask_reg]
    #    else:
    #        read_regs = []
    #    await self.wait_for_rf_available(write_regs=dst_regs, read_regs=read_regs)
    #    rf_write_ident = self.rf_info.start(read_regs=read_regs, write_regs=dst_regs)
    #    witem = cache_table.WaitingLoadStride(
    #            params=self.params, instr=instr, rf_ident=rf_write_ident)
    #    await self.cache_table.add_witem(witem=witem, k_maddr=instr.k_maddr)

    #async def handle_load_stride_instr_send_finished(self, witem: cache_table.WaitingLoadStride):
    #    '''
    #    This is called when the jamlets for this kamlet have sent all their messages.
    #    It releases the registers and kicks off a lamlet wide synchonrization.
    #    '''
    #    instr = witem.item
    #    for pstate in witem.protocol_states:
    #        assert pstate == SendState.COMPLETE
    #    assert witem.rf_ident is not None
    #    dst_regs = self.get_regs(
    #            start_index=instr.start_index, n_elements=instr.n_elements,
    #            ew=instr.dst_ordering.ew, base_reg=instr.dst)
    #    if instr.mask_reg is not None:
    #        read_regs = [instr.mask_reg]
    #    else:
    #        read_regs = []
    #    logger.debug(f'kamlet ({self.min_x}, {self.min_y}): handle_load_stride_instr_write releasing regs {read_regs}')
    #    self.rf_info.finish(witem.rf_ident, read_regs=read_regs, write_regs=dst_regs)
    #    self.sync.finish(witem)

    #async def handle_load_stride_instr_receive_finished(self, witem: cache_table.WaitingLoadStride):
    #    '''
    #    This is called when all jamlets in all kamlets have sent and received responses for all their
    #    messages. After this we can delete the witem.
    #    '''
    #    pass

    def get_is_active(self, start_index, n_elements, element_width, word_order, mask_reg, vline_index, j_in_k_index, index_in_j):
        '''
        Consider an element specified by:
          what vline_index in the vector it is
          what j_in_k_index it is in (what jamlet in the kamlet)
          what element it is in that work (index_in_j)
          what reg we're using for the masks
          we know what k_index is because we know what kamlet we are
        '''
        ww = self.params.word_bytes * 8
        ew = element_width
        elements_in_vline = self.params.vline_bytes*8//ew
        jamlet = self.jamlets[j_in_k_index]
        vw_index = addresses.k_indices_to_vw_index(
                self.params, word_order, self.k_index, j_in_k_index)
        element_index = vline_index*elements_in_vline + index_in_j * self.params.j_in_l + vw_index
        valid_element = start_index <= element_index < n_elements
        if mask_reg is not None:
            mask_bit_addr = mask_reg * ww + element_index//self.params.j_in_l
            mask_byte = jamlet.rf_slice[mask_bit_addr//8]
            mask_bit = (mask_byte >> (mask_bit_addr % 8)) & 1
        else:
            mask_bit = 1
        return valid_element, mask_bit

    async def handle_item(self, witem: WaitingItem) -> None:
        await witem.finalize(self)
        source_x, source_y = None, None
        if witem.source is not None:
            source_x, source_y = witem.source
        self.monitor.complete_witem(witem.instr_ident, self.min_x, self.min_y,
                                    source_x=source_x, source_y=source_y)

    async def _monitor_witems(self) -> None:
        while True:
            await self.clock.next_cycle
            witems = list(self.cache_table.waiting_items)
            #if witems:
            #    summaries = []
            #    for item in witems:
            #        name = type(item).__name__
            #        ident = item.instr_ident
            #        states = getattr(item, 'transaction_states', None)
            #        if states is not None:
            #            from zamlet.kamlet.cache_table import SendState
            #            counts = {}
            #            for s in states:
            #                counts[s.name[0]] = counts.get(s.name[0], 0) + 1
            #            state_str = '/'.join(f'{v}{k}' for k, v in counts.items())
            #        else:
            #            state_str = 'ready' if item.ready() else 'pending'
            #        summaries.append(f'{name}[{ident}]:{state_str}')
            #    logger.info(
            #        f'{self.clock.cycle}: kamlet ({self.min_x},{self.min_y}) '
            #        f'monitor_witems: {len(witems)} items: '
            #        + ', '.join(summaries))
            for item in witems:
                if item not in self.cache_table.waiting_items:
                    continue
                await item.monitor_kamlet(self)
                if item.ready():
                    self.cache_table.waiting_items.remove(item)
                    await self.handle_item(item)
                    break

    async def _send_packets(self) -> None:
        while True:
            await self.clock.next_cycle
            if self._instr_send_queue:
                packet = self._instr_send_queue.popleft()
                send_index = self.params.send_read_line_j_index
                buffer = self.jamlets[send_index].send_queues[packet[0].message_type]
                while not buffer.can_append():
                    await self.clock.next_cycle
                buffer.append(packet)
