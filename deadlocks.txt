Need to understand how to avoid deadlocks in message-passing protocols.

One example is
  1)  Write to a node
  2)  Read from that node many times

If the (2) packets arrive at the node first they will be blocked due to cache coherency.
This will prevent the (1) write packet from arriving at the node and thus we will have a deadlock.

Possible solutions:
  - Separate channels for reads and writes.
  - Don't send the reads until we know the write is finished.
  - Don't send more reads that we know will fit in the 'processing read' buffer until the write happens (this is probably not possible because the reads could come from many places).
  - End-to-end flow control would work for not sending too many reads but this would increase latency a lot. And that would have to be negotiated on a separeate channel anyway probably.


Potentially useful articles:
Ref 1) Avoiding message dependent deadlock in netework-based systems on chip
Ref 2) Deadlock verification of cache coherencde protocols and communication fabrics
Reg 3) A progressive approach to handling message dependent deadlock in parallel computer systems


There is an even simpler example in a paper.  Just two nodes both trying to read from each other.
Reg 1) Figure 2 shows a message dependent deadlock occurs between two request-response pairs that do not interact but use the same routing resources.

The reference introduces the message type and message chains.
They say you need buffers for each message type and you need to always consume messages.

A A A A B B B B C C C C D D D D
If A tries to read from C and D tries to read from B we could get deadlock since reads couldn't get accepted becaud they're responses can't move forward.

Two separate channels.
  - Sending droppable messages (consumable if we can send a response)
  - Responses for droppable messages. (always consumable)

Message kinds:
  - always consumable
  - consumable if we can send a message for type m_k

Have a network for always consumable messages.

1) An always consumable message (no problem)
2) A message that requires sending an always consumable mesage to be consumed.
     this creates a problem.  We need a separate network or flow control.
     but flow control introduces more messages so we need multiple networks

1) Network (A) takes always consumable messages.  Can never block.
2) Network (B) takes droppable messages. These can consume as long as they can send a response on (A)
    so they can never block.

So to do a read we send:
  a) A droppable read request.
  b) We receive either
      1) a read response
      2) a dropped read notification
  We have a small number of read statuses.  We don't send more reads until those reads have resolved.




