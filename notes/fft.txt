Let's say we're doing a 256 point fft on a 4x4 grid.

 8 4 0 -> X X X X
 9 5 1 -> X X X X
10 6 2 -> X X X X
11 7 3 -> X X X X

The first node will end up with 00000000, 10000000 to 11110000
The second node will get        00001000 to 11111000
The third node will get         00000100 to 11110100
The fourth node will get        00001100 to 11111100

Now within each node we can do a local FFT.  They have 16 entries.
So 4 stages and in each stage 8 butterfly ops.

All nodes need 8 twiddle factors for the 16 point FFT.
First 4 stage done internally within each lane.

For the 5th stage nodes we form pairs of nodes.
One node takes both upper halves of the data.
One node takes both lower halves of the data.
They do the computation then pass the answer back.
Each node needs 4 new twiddles.

Whether you're an upper or lower in a stage depends on your lane index and the bit in the index corresponding to the stage.
What node you're swapping data with is your own index + some power of two depending on the stage
If you're an upper you grab 4 upper tw factor from the last stage, grab the 4 new ones and interleave
   you're an upper you grabe 4 lower tw factor from the ....

R1 = 0     (Addr1)
R2 = R1+1  (Addr2)
R3 = TW0Addr

butterfly
R4 = Load(R1)
R5 = Load(R2)
R6 = Load(R3)
R4 = R4 * R6
R6 = R4 + R5
R4 = R4 - R5
R6 -> Store(R1)
R4 -> Store(R2)

Layout in the VLIW
R4=load(R1)  
R6=load(R3)   R4=R4*R6
R5=load(R3)   R6=R4+R5
R6->Store(R1) R4=R4-R5
R6->Store(R4)

Howabout if we do four butterflies
We have 4 inputs and 4 twiddles
We pass in the addresses for the inputs R8-R11 and the twiddles R12-R15

This is more efficient but uses more registers.
R1 = Load(R8)
R2 = Load(R12)   R1=R1*R2  (B+TW for first butterfly)
R2 = Load(R9)    R3=R1+R2
R4 = Load(R10)   R1=R1-R2  (R2 free)  (R1 and R3 store results)
R2 = Load(R11)   R2=R4*R2  (R4 free)
R4 = Load(R13)   R5=R2+R4  
R7 = Load(R14)   R6=R2-R4   (R1, R3, R5 and R6 store results) (R2 and R4 are free)
R2 = Load(R15)   R7=R7*R5   (1,3,5,6 intermed)  (7 working) (2, 4 free)
R5 -> Store(R8)  R5=R7+R1   
R5 -> Store(R10) R5=R7-R1
                 R5=R2*R6
R1 -> Store(R11) R1=R5+R3
R1 -> Store(R11) R1=R5-R3

What about if we pass in the 'stage' and the address of the first one.
R8 - stage
R9 - butterflies in stage
R10 - log(butterflies in stage)

Twiddles factors in each stage are (given by index of the 8 twiddle factors)
In the first  0, 0, 0, 0, 0, 0, 0, 0  (incr by 2^(3-stage)) then moduluo 8
       second 0, 4, 0, 4, 0, 4, 0, 4
       third  0, 2, 4, 6, 0, 2, 4, 6
       fourth 0, 1, 2, 3, 4, 5, 6, 7

                 R1=0      # Set twiddle first address to 0
                 R2=R10-R8   # Get R10 - stage
                 R2=1<<R2  # Get 2^(R10-stage)  (increment for twiddle address)  (1 is in imm)
                 R3=R2<<1  # Increment for twiddle in next stage
                 R3=1<<R8  # Increment for stage
                 R4=0      # Index of the first element
R1 - n_stages
R2 - fft_size/2
R15 - log2(fft_size/2) (size of twiddle step in first stage)
R14 - mask for twiddle

                                R4 = 1                         # Step for index
Loop R1 -> R1                   R3 = 0                         # Index of first element
                                R9 = 0                         # Index of first twiddle in this stage
                                R10 = 0                        # Index of first twiddle in next stage
                                R13 = R15 << 1                 # Twiddle step in step stage
Loop R2 -> R2   R5=Load(R3)     R3 = R3 + R4                   # Loading 4 values          
                R6=Load(R3)     R3 = R3 + R4
                R7=Load(R3)     R3 = R3 + R4
                R8=Load(R3)     R3 = R3 + R4 
                R11=Load(R9)   *R11 = R6 * R11
                               *R6 =  R11 + R5                 # Get two intermed values
                               *R5 =  R11 - R5
                                R9 = R9 + R15
                                R9 = R9 & R14                  # Get new twiddle address
                R11=Load(R9)   *R11 = R8*R11
                               *R8 = R11 + R7
                               *R7 = R11 - R7                  # Now we have 4 intermed values
                                R9 = R9 + R15
                                R9 = R9 & R14                  # Get new twiddle address
                R11=Load(R10)  *R11 = R5*R11
                R5->Store(R3)  *...
                R6->Store(??)  *...
                                R10 = R10 + R13                # Get the next stage twiddle address
                                R10 = R10 & R14
                R11=Load(R10)  *R11 =R7*R11 
                               *...
                               *...
                                R10 = R10 + R13                # Get the next stage twiddle address
                                R10 = R10 & R14

        It really tough to do 2 stages of 2 butterflys in 16 registers.
        The ALU is spending most of it's time doing memory address calculations

What would this look like if we had an ALULite with 16-bit registers R16-R31 (R16 is 0)

R17 - n_stages
R18 - fft_size/4
R19 - log2(fft_size/2)
R20 - mask for twiddle

                                 R24 = 4                   # Step for index
                                 R26 = 0                   # Index of first twiddle in this stage
                                 R27 = 0                   # Index of first twiddle in next stage
                                 R28 = R19 - 1
                                 R28 = 1 << R28            # Twiddle step size in this stage
                                 R29 = R28 >> 1            # Twiddle step size in next stage
Loop R17 -> R30
                                 R25 = 0                   # Index of first element
                                 R21 = 1
                                 R22 = -2 (coz we increment at beginning)
                                 R23 = 3
Loop R18 -> R18
                 R8=Load(R25)    R22 = R22 + 4
                 R10=Load(R26)   R26 = R26 + R28   R10=R8*R10
                 R9=Load(R21)    R26 = R26 & R20   R8=R10+R9
                 R12=Load(R22)                     R9=R10-R9
                 R10=Load(R26)   R26 = R26 + R28   R10=R12*R10
                 R13=Load(R23)   R26 = R26 & R20   R12=R10+R13
                 R10=Load(R27)   R27 = R27 + R29   R13=R10-R13
                                 R27 = R27 & R20   R10=R10*R12
                 R8->Store(R25)  R25 = R25 + R24   R8=R10+R12
                 R12->Store(R22) R21 = R21 + R24   R12=R10-R12
                 R10=Load(R27)   R27 = R27 + R29   R10=R10*R13
                 R13->Store(R23) R27 = R27 & R20   R13=R10+R9
                 R9->Store(R21)  R23 = R23 + R24   R9=R10-R9

                
                                
  










